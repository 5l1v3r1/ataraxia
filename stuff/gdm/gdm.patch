diff -ruN gdm-3.34.0-orig/common/gdm-address.c gdm-3.34.0/common/gdm-address.c
--- gdm-3.34.0-orig/common/gdm-address.c	2019-02-22 04:44:14.000000000 +0900
+++ gdm-3.34.0/common/gdm-address.c	2019-09-17 00:40:47.181447114 +0900
@@ -29,6 +29,8 @@
 #include <stropts.h>
 #endif
 #include <string.h>
+#include <sys/types.h>
+#include <sys/param.h>
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -37,7 +39,6 @@
 #endif
 #include <netdb.h>
 #include <sys/ioctl.h>
-#include <net/if.h>
 
 #ifndef G_OS_WIN32
 #include <sys/select.h>
@@ -47,6 +48,7 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #endif
+#include <net/if.h>
 
 #include <glib-object.h>
 
diff -ruN gdm-3.34.0-orig/common/gdm-common.c gdm-3.34.0/common/gdm-common.c
--- gdm-3.34.0-orig/common/gdm-common.c	2019-08-14 04:42:23.000000000 +0900
+++ gdm-3.34.0/common/gdm-common.c	2019-09-17 00:49:44.395147803 +0900
@@ -36,12 +36,25 @@
 
 #include "gdm-common.h"
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #define GDM_DBUS_NAME                            "org.gnome.DisplayManager"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_PATH      "/org/gnome/DisplayManager/LocalDisplayFactory"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_INTERFACE "org.gnome.DisplayManager.LocalDisplayFactory"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
 G_DEFINE_QUARK (gdm-common-error, gdm_common_error);
 
 gboolean
@@ -352,8 +365,87 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
+gboolean
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
 gboolean
-gdm_activate_session_by_id (GDBusConnection *connection,
+activate_session_id_for_ck (GDBusConnection *connection,
                             const char      *seat_id,
                             const char      *session_id)
 {
@@ -361,6 +453,217 @@
         GVariant *reply;
 
         reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to activate session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+       gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
+static gboolean
+goto_login_session_for_ck (GDBusConnection  *connection,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_COMMON_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_COMMON_ERROR, 1, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, seat_id, session_id);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+
+gboolean
+activate_session_id_for_systemd (GDBusConnection *connection,
+                                 const char      *seat_id,
+                                 const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
                                              "org.freedesktop.login1.Manager",
@@ -382,8 +685,8 @@
 }
 
 gboolean
-gdm_get_login_window_session_id (const char  *seat_id,
-                                 char       **session_id)
+get_login_window_session_id_for_systemd (const char  *seat_id,
+                                         char       **session_id)
 {
         gboolean   ret;
         int        res, i;
@@ -476,8 +779,8 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
-                    GError          **error)
+goto_login_session_for_systemd (GDBusConnection  *connection,
+                                GError          **error)
 {
         gboolean        ret;
         int             res;
@@ -530,9 +833,9 @@
                 return FALSE;
         }
 
-        res = gdm_get_login_window_session_id (seat_id, &session_id);
+        res = get_login_window_session_id_for_systemd (seat_id, &session_id);
         if (res && session_id != NULL) {
-                res = gdm_activate_session_by_id (connection, seat_id, session_id);
+                res = activate_session_id_for_systemd (connection, seat_id, session_id);
 
                 if (res) {
                         ret = TRUE;
@@ -551,6 +854,7 @@
 
         return ret;
 }
+#endif
 
 gboolean
 gdm_goto_login_session (GError **error)
@@ -566,7 +870,17 @@
                 return FALSE;
         }
 
-        return goto_login_session (connection, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return goto_login_session_for_systemd (connection, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return goto_login_session_for_ck (connection, error);
+#else
+        return FALSE;
+#endif
 }
 
 static void
@@ -850,7 +1164,11 @@
         int saved_errno;
         g_autofree gchar *type = NULL;
 
+#ifdef HAVE_SYSTEMD
         saved_errno = sd_session_get_type (session_id, &type);
+#else
+        saved_errno = 1;
+#endif
         if (saved_errno < 0) {
                 g_warning ("Couldn't get type for session '%s': %s",
                            session_id,
@@ -881,7 +1199,11 @@
          * checking for a race condition since we specified
          * GDM_SYSTEMD_SESSION_REQUIRE_ONLINE)
          */
+#ifdef HAVE_SYSTEMD
         saved_errno = sd_session_get_state (session_id, &state);
+#else
+        saved_errno = 1;
+#endif
         if (saved_errno < 0) {
                 g_warning ("Couldn't get state for session '%s': %s",
                            session_id,
@@ -910,9 +1232,13 @@
 
         g_debug ("Finding a graphical session for user %d", uid);
 
+#ifdef HAVE_SYSTEMD
         n_sessions = sd_uid_get_sessions (uid,
                                           GDM_SYSTEMD_SESSION_REQUIRE_ONLINE,
                                           &sessions);
+#else
+        n_sessions = 1;
+#endif
 
         if (n_sessions < 0) {
                 g_set_error (error,
diff -ruN gdm-3.34.0-orig/common/gdm-common.h gdm-3.34.0/common/gdm-common.h
--- gdm-3.34.0-orig/common/gdm-common.h	2019-08-14 04:42:23.000000000 +0900
+++ gdm-3.34.0/common/gdm-common.h	2019-09-17 00:40:47.185447032 +0900
@@ -37,6 +37,9 @@
 
 #define GDM_SYSTEMD_SESSION_REQUIRE_ONLINE 0
 
+/* check if logind is running */
+#define LOGIND_RUNNING() (access("/run/systemd/seats/", F_OK) >= 0)
+
 GQuark gdm_common_error_quark (void);
 #define GDM_COMMON_ERROR gdm_common_error_quark()
 
@@ -82,10 +85,6 @@
                                            GdmExpandVarFunc expand_func,
                                            gpointer user_data);
 
-gboolean      gdm_activate_session_by_id (GDBusConnection *connection,
-                                          const char      *seat_id,
-                                          const char      *session_id);
-
 G_END_DECLS
 
 #endif /* _GDM_COMMON_H */
diff -ruN gdm-3.34.0-orig/common/gdm-log.c gdm-3.34.0/common/gdm-log.c
--- gdm-3.34.0-orig/common/gdm-log.c	2019-02-22 04:44:14.000000000 +0900
+++ gdm-3.34.0/common/gdm-log.c	2019-09-17 00:40:47.185447032 +0900
@@ -30,7 +30,9 @@
 #include <unistd.h>
 
 #include <syslog.h>
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #include <glib.h>
 #include <glib/gstdio.h>
@@ -125,12 +127,35 @@
 void
 gdm_log_init (void)
 {
+	const char *prg_name;
+	int         options;
+
         if (initialized)
                 return;
 
         initialized = TRUE;
 
+#ifdef WITH_SYSTEMD
+        is_sd_booted = sd_booted () > 0;
+#endif
+
         g_log_set_default_handler (gdm_log_default_handler, NULL);
+
+        /* Only set up syslog if !systemd, otherwise with systemd
+         * enabled, we keep the default GLib log handler which goes to
+         * stderr, which is routed to the appropriate place in the
+         * systemd service file.
+         */
+        if (!is_sd_booted) {
+                prg_name = g_get_prgname ();
+
+                options = LOG_PID;
+#ifdef LOG_PERROR
+                options |= LOG_PERROR;
+#endif
+
+                openlog (prg_name, options, LOG_DAEMON);
+        }
 }
 
 void
diff -ruN gdm-3.34.0-orig/configure.ac gdm-3.34.0/configure.ac
--- gdm-3.34.0-orig/configure.ac	2019-09-11 21:45:59.000000000 +0900
+++ gdm-3.34.0/configure.ac	2019-09-17 00:40:47.185447032 +0900
@@ -224,12 +224,6 @@
 AM_CONDITIONAL(ENABLE_LFS_PAM_CONFIG, test x$with_default_pam_config = xlfs)
 AM_CONDITIONAL(ENABLE_ARCH_PAM_CONFIG, test x$with_default_pam_config = xarch)
 
-AC_CHECK_HEADERS([security/pam_modules.h security/pam_modutil.h security/pam_ext.h],
-                 [have_pam=yes],
-                 [if test "x$have_pam" = xyes ; then
-                        AC_MSG_ERROR([PAM development files not found.])
-                 fi])
-
 AC_ARG_ENABLE(console-helper,
 	      AS_HELP_STRING([--enable-console-helper],
                              [Enable PAM console helper @<:@default=auto@:>@]),,
@@ -259,6 +253,17 @@
             AS_HELP_STRING([--with-udevdir=DIR],
                            [Directory for udev files]),
                 [with_udevdir=$withval], [with_udevdir=$($PKG_CONFIG --variable=udevdir udev)])
+
+AC_ARG_WITH(console-kit,
+            AS_HELP_STRING([--with-console-kit],
+                           [Add ConsoleKit support @<:@default=auto@:>@]),,
+            with_console_kit=no)
+
+AC_ARG_WITH(systemd,
+            AS_HELP_STRING([--with-systemd],
+                           [Add systemd support @<:@default=auto@:>@]),
+            [with_systemd=$withval], [with_systemd=auto])
+
 AC_ARG_WITH([systemdsystemunitdir],
             AS_HELP_STRING([--with-systemdsystemunitdir=DIR],
                            [Directory for systemd service files]),
@@ -530,6 +535,8 @@
 if test "x$supports_pam_extensions" = "xyes" ; then
 	AM_CONDITIONAL(SUPPORTS_PAM_EXTENSIONS, true)
 	AC_DEFINE(SUPPORTS_PAM_EXTENSIONS, 1, [Define if PAM supports GDMs custom extensions])
+else
+	AM_CONDITIONAL(SUPPORTS_PAM_EXTENSIONS, false)
 fi
 
 AC_CHECK_LIB(keyutils, keyctl_read, [
@@ -613,14 +620,8 @@
 dnl - Check for utmp stuff
 dnl ---------------------------------------------------------------------------
 
-AC_CHECK_HEADERS(utmp.h utmpx.h libutil.h sys/param.h)
-AC_CHECK_FUNCS([getutxent updwtmpx updwtmp])
-AC_CHECK_LIB(util, login, [
-		   AC_DEFINE(HAVE_LOGIN, 1, [Define if have login])
-		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
-AC_CHECK_LIB(util, logout, [
-		   AC_DEFINE(HAVE_LOGOUT, 1, [Define if have logout])
-		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
+AC_CHECK_HEADERS(utmp.h utmpx.h util.h sys/param.h)
+AC_CHECK_FUNCS([getutxent getttyent updwtmpx updwtmp])
 AC_CHECK_LIB(util, logwtmp, [
 	  	   AC_DEFINE(HAVE_LOGWTMP, 1, [Define if have logwtmp])
 		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
@@ -829,12 +830,42 @@
 CPPFLAGS="$xinerama_save_cppflags"
 
 dnl ---------------------------------------------------------------------------
+dnl - Check for ConsoleKit support
+dnl ---------------------------------------------------------------------------
+
+use_console_kit=no
+if test "x$with_console_kit" != "xno" ; then
+	use_console_kit=yes
+	AC_DEFINE(WITH_CONSOLE_KIT, 1, [Define to enable ConsoleKit support])
+fi
+AM_CONDITIONAL(WITH_CONSOLE_KIT, test x$use_console_kit = xyes)
+AC_SUBST(WITH_CONSOLE_KIT)
+
+dnl ---------------------------------------------------------------------------
 dnl - Check for systemd support
 dnl ---------------------------------------------------------------------------
 
 PKG_CHECK_MODULES(SYSTEMD,
-                  [libsystemd])
+                  [libsystemd-login >= 186 libsystemd-daemon],
+                  [have_systemd=yes], [have_systemd=no])
 
+if test "x$with_systemd" = "xauto" ; then
+        if test x$have_systemd = xno ; then
+                use_systemd=no
+        else
+                use_systemd=yes
+        fi
+else
+        use_systemd="$with_systemd"
+fi
+
+if test "x$use_systemd" != "xno" ; then
+        if test "x$have_systemd" = "xno"; then
+                AC_MSG_ERROR([Systemd support explicitly required, but systemd not found])
+        fi
+
+        AC_DEFINE(WITH_SYSTEMD, 1, [Define to enable systemd support])
+fi
 AC_SUBST(SYSTEMD_CFLAGS)
 AC_SUBST(SYSTEMD_LIBS)
 
@@ -1027,6 +1058,14 @@
 AC_SUBST(GDM_CUSTOM_CONF)
 AC_SUBST(GDM_OLD_CONF, '${gdmconfdir}/gdm.conf')
 
+AC_ARG_WITH(consolekit-directory,
+              [AC_HELP_STRING([--with-consolekit-directory],
+                              [Specify the directory of ck-get-x11-display-device @<:@default=libexecdir@:>@])],,
+                              [with_consolekit_directory="\${libexecdir}"])
+
+CONSOLEKIT_DIR=$with_consolekit_directory
+AC_SUBST(CONSOLEKIT_DIR)
+
 AC_ARG_WITH(gnome-settings-daemon-directory,
               [AC_HELP_STRING([--with-gnome-settings-daemon-directory],
                               [Specify the directory of gnome-settings-daemon used by the chooser @<:@default=libexecdir@:>@])],,
@@ -1490,6 +1529,7 @@
         dmconfdir:                ${dmconfdir}
         localstatedir:            ${localstatedir}
         datadir:                  ${datadir}
+	consolekit location:      ${with_consolekit_directory}
 	gnome-settings-daemon location: ${with_gnome_settings_daemon_directory}
 	gnome-session-check-accel location: ${with_check_accelerated_directory}
 	source code location:	  ${srcdir}
@@ -1520,6 +1560,8 @@
 "        Xinerama support:         ${XINERAMA_SUPPORT}
         XDMCP support:            ${XDMCP_SUPPORT}
         SELinux support:          ${use_selinux}
+        ConsoleKit support:       ${use_console_kit}
+        systemd support:          ${use_systemd}
         systemd unit dir:         ${with_systemdsystemunitdir}
         udev dir:                 ${with_udevdir}
         plymouth support:         ${use_plymouth}
@@ -1529,3 +1571,4 @@
         Enable documentation:     ${enable_documentation}
         Install GDM's Xsession:   ${enable_gdm_xsession}
 "
+
diff -ruN gdm-3.34.0-orig/daemon/gdm-display.c gdm-3.34.0/daemon/gdm-display.c
--- gdm-3.34.0-orig/daemon/gdm-display.c	2019-09-05 04:22:28.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-display.c	2019-09-17 00:40:47.185447032 +0900
@@ -242,8 +242,8 @@
         host_entries[1].address   = "localuser\0" GDM_USERNAME;
         host_entries[1].length    = sizeof ("localuser\0" GDM_USERNAME);
         host_entries[2].family    = FamilyServerInterpreted;
-        host_entries[2].address   = "localuser\0gnome-initial-setup";
-        host_entries[2].length    = sizeof ("localuser\0gnome-initial-setup");
+        host_entries[2].address   = "localuser\0_gnome-initial-setup";
+        host_entries[2].length    = sizeof ("localuser\0_gnome-initial-setup");
 }
 
 gboolean
@@ -1150,7 +1150,6 @@
 register_display (GdmDisplay *self)
 {
         GdmDisplayPrivate *priv;
-        GError *error = NULL;
 
         priv = gdm_display_get_instance_private (self);
 
diff -ruN gdm-3.34.0-orig/daemon/gdm-launch-environment.c gdm-3.34.0/daemon/gdm-launch-environment.c
--- gdm-3.34.0-orig/daemon/gdm-launch-environment.c	2019-08-14 10:37:16.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-launch-environment.c	2019-09-17 00:40:47.189446949 +0900
@@ -50,7 +50,7 @@
 #include "gdm-settings-direct.h"
 #include "gdm-settings-keys.h"
 
-#define INITIAL_SETUP_USERNAME "gnome-initial-setup"
+#define INITIAL_SETUP_USERNAME "_gnome-initial-setup"
 #define GDM_SESSION_MODE "gdm"
 #define INITIAL_SETUP_SESSION_MODE "initial-setup"
 #define GNOME_SESSION_SESSIONS_PATH DATADIR "/gnome-session/sessions"
@@ -212,6 +212,9 @@
                 char *seat_id;
 
                 seat_id = launch_environment->priv->x11_display_seat_id;
+                if (g_str_has_prefix (seat_id, "/org/freedesktop/ConsoleKit/")) {
+                        seat_id += strlen ("/org/freedesktop/ConsoleKit/");
+                }
 
                 g_hash_table_insert (hash, g_strdup ("GDM_SEAT_ID"), g_strdup (seat_id));
         }
@@ -237,6 +240,8 @@
                 gdm_session_set_environment_variable (launch_environment->priv->session, key, value);
         }
         g_hash_table_destroy (hash);
+
+        gdm_session_select_session_type (launch_environment->priv->session, "LoginWindow");
 }
 
 static void
diff -ruN gdm-3.34.0-orig/daemon/gdm-local-display-factory.c gdm-3.34.0/daemon/gdm-local-display-factory.c
--- gdm-3.34.0-orig/daemon/gdm-local-display-factory.c	2019-09-05 04:22:36.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-local-display-factory.c	2019-09-17 00:40:47.189446949 +0900
@@ -28,7 +28,9 @@
 #include <glib-object.h>
 #include <gio/gio.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 #include "gdm-manager.h"
@@ -42,6 +44,8 @@
 #include "gdm-local-display.h"
 #include "gdm-legacy-display.h"
 
+#define CK_SEAT1_PATH                       "/org/freedesktop/ConsoleKit/Seat1"
+
 #define GDM_DBUS_PATH                       "/org/gnome/DisplayManager"
 #define GDM_LOCAL_DISPLAY_FACTORY_DBUS_PATH GDM_DBUS_PATH "/LocalDisplayFactory"
 #define GDM_MANAGER_DBUS_NAME               "org.gnome.DisplayManager.LocalDisplayFactory"
@@ -60,8 +64,10 @@
         /* FIXME: this needs to be per seat? */
         guint            num_failures;
 
+#ifdef WITH_SYSTEMD
         guint            seat_new_id;
         guint            seat_removed_id;
+#endif
 
 #if defined(ENABLE_WAYLAND_SUPPORT) && defined(ENABLE_USER_DISPLAY_SERVER)
         unsigned int     active_vt;
@@ -87,7 +93,9 @@
                                                          GParamSpec                  *arg1,
                                                          GdmLocalDisplayFactory      *factory);
 
+#ifdef WITH_SYSTEMD
 static gboolean gdm_local_display_factory_sync_seats    (GdmLocalDisplayFactory *factory);
+#endif
 static gpointer local_display_factory_object = NULL;
 static gboolean lookup_by_session_id (const char *id,
                                       GdmDisplay *display,
@@ -231,7 +239,7 @@
 
         g_debug ("GdmLocalDisplayFactory: Creating transient display");
 
-#ifdef ENABLE_USER_DISPLAY_SERVER
+#if defined ENABLE_USER_DISPLAY_SERVER && defined WITH_SYSTEMD
         display = gdm_local_display_new ();
         if (gdm_local_display_factory_use_wayland ())
                 g_object_set (G_OBJECT (display), "session-type", "wayland", NULL);
@@ -370,7 +378,7 @@
                         /* reset num failures */
                         factory->num_failures = 0;
 
-                        gdm_local_display_factory_sync_seats (factory);
+			create_display (factory, seat_id, session_type, is_initial);
                 }
                 break;
         case GDM_DISPLAY_FAILED:
@@ -464,15 +472,19 @@
 {
         GdmDisplayStore *store;
         GdmDisplay      *display = NULL;
+#ifdef WITH_SYSTEMD
         g_autofree char *login_session_id = NULL;
+#endif
 
         g_debug ("GdmLocalDisplayFactory: %s login display for seat %s requested",
                  session_type? : "X11", seat_id);
         store = gdm_display_factory_get_display_store (GDM_DISPLAY_FACTORY (factory));
 
+#ifdef WITH_SYSTEMD
         if (sd_seat_can_multi_session (seat_id))
                 display = gdm_display_store_find (store, lookup_prepared_display_by_seat_id, (gpointer) seat_id);
         else
+#endif
                 display = gdm_display_store_find (store, lookup_by_seat_id, (gpointer) seat_id);
 
         /* Ensure we don't create the same display more than once */
@@ -481,6 +493,7 @@
                 return NULL;
         }
 
+#ifdef WITH_SYSTEMD
         /* If we already have a login window, switch to it */
         if (gdm_get_login_window_session_id (seat_id, &login_session_id)) {
                 GdmDisplay *display;
@@ -494,14 +507,15 @@
                         g_object_set (G_OBJECT (display), "status", GDM_DISPLAY_MANAGED, NULL);
                         g_debug ("GdmLocalDisplayFactory: session %s found, activating.",
                                  login_session_id);
-                        gdm_activate_session_by_id (factory->connection, seat_id, login_session_id);
+                        activate_session_id (factory->connection, seat_id, login_session_id);
                         return NULL;
                 }
         }
+#endif
 
         g_debug ("GdmLocalDisplayFactory: Adding display on seat %s", seat_id);
 
-#ifdef ENABLE_USER_DISPLAY_SERVER
+#if defined ENABLE_USER_DISPLAY_SERVER && defined WITH_SYSTEMD
         if (g_strcmp0 (seat_id, "seat0") == 0) {
                 display = gdm_local_display_new ();
                 if (session_type != NULL) {
@@ -533,6 +547,7 @@
         return display;
 }
 
+#ifdef WITH_SYSTEMD
 static void
 delete_display (GdmLocalDisplayFactory *factory,
                 const char             *seat_id) {
@@ -886,6 +901,7 @@
         }
 #endif
 }
+#endif
 
 static void
 gdm_local_display_factory_stop_monitor (GdmLocalDisplayFactory *factory)
@@ -944,6 +960,7 @@
 gdm_local_display_factory_start (GdmDisplayFactory *base_factory)
 {
         GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (base_factory);
+        GdmDisplay             *display;
         GdmDisplayStore *store;
 
         g_return_val_if_fail (GDM_IS_LOCAL_DISPLAY_FACTORY (factory), FALSE);
@@ -962,8 +979,17 @@
                                  factory,
                                  0);
 
-        gdm_local_display_factory_start_monitor (factory);
-        return gdm_local_display_factory_sync_seats (factory);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                gdm_local_display_factory_start_monitor (factory);
+                return gdm_local_display_factory_sync_seats (factory);
+        }
+#endif
+
+        /* On ConsoleKit just create Seat1, and that's it. */
+        display = create_display (factory, CK_SEAT1_PATH, NULL, TRUE);
+
+        return display != NULL;
 }
 
 static gboolean
@@ -974,7 +1000,9 @@
 
         g_return_val_if_fail (GDM_IS_LOCAL_DISPLAY_FACTORY (factory), FALSE);
 
+#ifdef WITH_SYSTEMD
         gdm_local_display_factory_stop_monitor (factory);
+#endif
 
         store = gdm_display_factory_get_display_store (GDM_DISPLAY_FACTORY (factory));
 
@@ -1126,7 +1154,9 @@
 
         g_hash_table_destroy (factory->used_display_numbers);
 
+#ifdef WITH_SYSTEMD
         gdm_local_display_factory_stop_monitor (factory);
+#endif
 
         G_OBJECT_CLASS (gdm_local_display_factory_parent_class)->finalize (object);
 }
diff -ruN gdm-3.34.0-orig/daemon/gdm-manager.c gdm-3.34.0/daemon/gdm-manager.c
--- gdm-3.34.0-orig/daemon/gdm-manager.c	2019-09-04 23:57:30.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-manager.c	2019-09-17 00:40:47.189446949 +0900
@@ -36,7 +36,9 @@
 
 #include <act/act-user-manager.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 
@@ -61,9 +63,18 @@
 #define GDM_MANAGER_PATH          GDM_DBUS_PATH "/Manager"
 #define GDM_MANAGER_DISPLAYS_PATH GDM_DBUS_PATH "/Displays"
 
-#define INITIAL_SETUP_USERNAME "gnome-initial-setup"
+#define INITIAL_SETUP_USERNAME "_gnome-initial-setup"
 #define ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT GDM_RUN_DIR "/gdm.ran-initial-setup"
 
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+
 typedef struct
 {
         GdmManager *manager;
@@ -205,9 +216,10 @@
 }
 #endif
 
+#ifdef WITH_SYSTEMD
 static char *
-get_session_id_for_pid (pid_t    pid,
-                        GError **error)
+get_session_id_for_pid_systemd (pid_t    pid,
+                                GError **error)
 {
         char *session, *gsession;
         int ret;
@@ -232,11 +244,61 @@
                 return NULL;
         }
 }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+static char *
+get_session_id_for_pid_consolekit (GDBusConnection  *connection,
+                                   pid_t             pid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForUnixProcess",
+                                             g_variant_new ("(u)", pid),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
 
+static char *
+get_session_id_for_pid (GDBusConnection  *connection,
+                        pid_t             pid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_session_id_for_pid_systemd (pid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_session_id_for_pid_consolekit (connection, pid, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
 static gboolean
-get_uid_for_session_id (const char  *session_id,
-                        uid_t       *uid,
-                        GError     **error)
+get_uid_for_systemd_session_id (const char  *session_id,
+                                uid_t       *uid,
+                                GError     **error)
 {
         int ret;
 
@@ -253,6 +315,60 @@
 
         return TRUE;
 }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+get_uid_for_consolekit_session_id (GDBusConnection  *connection,
+                                   const char       *session_id,
+                                   uid_t            *out_uid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        guint32 uid;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetUnixUser",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(u)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(u)", &uid);
+        g_variant_unref (reply);
+
+        *out_uid = (uid_t) uid;
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+get_uid_for_session_id (GDBusConnection  *connection,
+                        const char       *session_id,
+                        uid_t            *uid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_uid_for_systemd_session_id (session_id, uid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_uid_for_consolekit_session_id (connection, session_id, uid, error);
+#endif
+
+        return FALSE;
+}
 
 static gboolean
 lookup_by_session_id (const char *id,
@@ -266,10 +382,50 @@
         return g_strcmp0 (current, looking_for) == 0;
 }
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+is_consolekit_login_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
+{
+        GVariant *reply;
+        char *session_type = NULL;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(s)", &session_type);
+        g_variant_unref (reply);
+
+        if (g_strcmp0 (session_type, "LoginWindow") != 0) {
+                g_free (session_type);
+
+                return FALSE;
+        }
+
+        g_free (session_type);
+        return TRUE;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
 static gboolean
-is_login_session (GdmManager  *self,
-                  const char  *session_id,
-                  GError     **error)
+is_systemd_login_session (GdmManager  *self,
+                          const char  *session_id,
+                          GError     **error)
 {
         char *session_class = NULL;
         int ret;
@@ -294,29 +450,49 @@
         g_free (session_class);
         return TRUE;
 }
+#endif
 
 static gboolean
-session_unlock (GdmManager *manager,
-                const char *ssid)
+is_login_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_login_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_login_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+activate_session_id_for_systemd (GdmManager   *manager,
+                                 const char *seat_id,
+                                 const char *session_id)
 {
         GError *error = NULL;
         GVariant *reply;
 
-        g_debug ("Unlocking session %s", ssid);
-
         reply = g_dbus_connection_call_sync (manager->priv->connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
                                              "org.freedesktop.login1.Manager",
-                                             "UnlockSession",
-                                             g_variant_new ("(s)", ssid),
+                                             "ActivateSessionOnSeat",
+                                             g_variant_new ("(ss)", session_id, seat_id),
                                              NULL, /* expected reply */
                                              G_DBUS_CALL_FLAGS_NONE,
                                              -1,
                                              NULL,
                                              &error);
         if (reply == NULL) {
-                g_debug ("GdmManager: logind 'UnlockSession' %s raised:\n %s\n\n",
+                g_debug ("GdmManager: logind 'ActivateSessionOnSeat' %s raised:\n %s\n\n",
                          g_dbus_error_get_remote_error (error), error->message);
                 g_error_free (error);
                 return FALSE;
@@ -326,6 +502,118 @@
 
         return TRUE;
 }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+activate_session_id_for_ck (GdmManager *manager,
+                            const char *seat_id,
+                            const char *session_id)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->priv->connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+
+                /* It is very likely that the "error" just reported is
+                 * that the session is already active.  Unfortunately,
+                 * ConsoleKit doesn't use proper error codes and it
+                 * translates the error message, so we have no real way
+                 * to detect this case...
+                 */
+                return TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+activate_session_id (GdmManager *manager,
+                     const char *seat_id,
+                     const char *session_id)
+{
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return activate_session_id_for_systemd (manager, seat_id, session_id);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return activate_session_id_for_ck (manager, seat_id, session_id);
+#else
+       return FALSE;
+#endif
+}
+
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+session_unlock_for_ck (GdmManager *manager,
+                       const char *ssid)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->priv->connection,
+                                             CK_NAME,
+                                             ssid,
+                                             CK_SESSION_INTERFACE,
+                                             "Unlock",
+                                             NULL, /* parameters */
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+session_unlock (GdmManager *manager,
+                const char *ssid)
+{
+
+        g_debug ("Unlocking session %s", ssid);
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return session_unlock_for_systemd (manager, ssid);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return session_unlock_for_ck (manager, ssid);
+#else
+        return TRUE;
+#endif
+}
 
 static GdmSession *
 find_session_for_user_on_seat (GdmManager *manager,
@@ -374,10 +662,43 @@
         return NULL;
 }
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-is_remote_session (GdmManager  *self,
-                   const char  *session_id,
-                   GError     **error)
+is_consolekit_remote_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
+{
+        GVariant *reply;
+        gboolean is_remote;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "IsLocal",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &is_remote);
+        g_variant_unref (reply);
+
+        return is_remote;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+static gboolean
+is_systemd_remote_session (GdmManager  *self,
+                           const char  *session_id,
+                           GError     **error)
 {
         char *seat;
         int ret;
@@ -403,10 +724,12 @@
 
         return is_remote;
 }
+#endif
 
+#ifdef WITH_SYSTEMD
 static char *
-get_seat_id_for_session_id (const char  *session_id,
-                            GError     **error)
+get_seat_id_for_systemd_session_id (const char  *session_id,
+                                    GError     **error)
 {
         int ret;
         char *seat, *out_seat;
@@ -431,11 +754,85 @@
 
         return out_seat;
 }
+#endif
+
+static gboolean
+is_remote_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_remote_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_remote_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
 
+#ifdef WITH_CONSOLE_KIT
 static char *
-get_tty_for_session_id (const char  *session_id,
-                        GError     **error)
+get_seat_id_for_consolekit_session_id (GDBusConnection  *connection,
+                                       const char       *session_id,
+                                       GError          **error)
 {
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSeatId",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_seat_id_for_session_id (GDBusConnection  *connection,
+                            const char       *session_id,
+                            GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_seat_id_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_seat_id_for_consolekit_session_id (connection, session_id, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
+static char *
+get_tty_for_systemd_session_id (const char  *session_id,
+                                GError     **error)
+{
+
+
+
+
         int ret;
         char *tty, *out_tty;
 
@@ -458,6 +855,20 @@
 
         return out_tty;
 }
+#endif
+
+static char *
+get_tty_for_session_id (const char  *session_id,
+                        GError     **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_tty_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+        return NULL;
+}
 
 static void
 get_display_and_details_for_bus_sender (GdmManager       *self,
@@ -516,7 +927,7 @@
         }
 
         if (out_is_login_screen != NULL) {
-                *out_is_login_screen = is_login_session (self, session_id, &error);
+                *out_is_login_screen = is_login_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while checking if sender is login screen: %s",
@@ -526,7 +937,7 @@
                 }
         }
 
-        if (!get_uid_for_session_id (session_id, &session_uid, &error)) {
+        if (!get_uid_for_session_id (connection, session_id, &session_uid, &error)) {
                 g_debug ("GdmManager: Error while retrieving uid for session: %s",
                          error->message);
                 g_error_free (error);
@@ -543,7 +954,7 @@
         }
 
         if (out_seat_id != NULL) {
-                *out_seat_id = get_seat_id_for_session_id (session_id, &error);
+                *out_seat_id = get_seat_id_for_session_id (connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving seat id for session: %s",
@@ -553,7 +964,7 @@
         }
 
         if (out_is_remote != NULL) {
-                *out_is_remote = is_remote_session (self, session_id, &error);
+                *out_is_remote = is_remote_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving remoteness for session: %s",
@@ -609,7 +1020,7 @@
         if (existing_session != NULL) {
                 ssid_to_activate = gdm_session_get_session_id (existing_session);
                 if (seat_id != NULL) {
-                        res = gdm_activate_session_by_id (manager->priv->connection, seat_id, ssid_to_activate);
+                        res = activate_session_id (manager, seat_id, ssid_to_activate);
                         if (! res) {
                                 g_debug ("GdmManager: unable to activate session: %s", ssid_to_activate);
                                 goto out;
@@ -711,29 +1122,6 @@
         return recorded;
 }
 
-static GdmSession *
-find_user_session_for_display (GdmManager *self,
-                               GdmDisplay *display)
-{
-
-        GList *node = self->priv->user_sessions;
-
-        while (node != NULL) {
-                GdmSession *session = node->data;
-                GdmDisplay *candidate_display;
-                GList *next_node = node->next;
-
-                candidate_display = get_display_for_user_session (session);
-
-                if (candidate_display == display)
-                        return session;
-
-                node = next_node;
-        }
-
-        return NULL;
-}
-
 static gboolean
 gdm_manager_handle_register_display (GdmDBusManager        *manager,
                                      GDBusMethodInvocation *invocation,
@@ -773,7 +1161,7 @@
                 }
         }
 
-        session = find_user_session_for_display (self, display);
+        session = get_user_session_for_display (display);
 
         if (session != NULL) {
                 GPid pid;
@@ -980,7 +1368,8 @@
                  * same audit session, ignore it since it doesn't "own" the
                  * reauthentication session
                  */
-                client_session_id = get_session_id_for_pid (pid_of_client,
+                client_session_id = get_session_id_for_pid (self->priv->connection,
+                                                            pid_of_client,
                                                             NULL);
                 session_id = g_object_get_data (G_OBJECT (session), "caller-session-id");
 
@@ -1199,16 +1588,19 @@
 display_is_on_seat0 (GdmDisplay *display)
 {
         gboolean is_on_seat0 = TRUE;
-        char *seat_id = NULL;
-
-        g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
 
-        if (g_strcmp0 (seat_id, "seat0") != 0) {
-            is_on_seat0 = FALSE;
-        }
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                char *seat_id = NULL;
+                g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
 
-        g_free (seat_id);
+                if (g_strcmp0 (seat_id, "seat0") != 0) {
+                        is_on_seat0 = FALSE;
+                }
 
+                g_free (seat_id);
+        }
+#endif
         return is_on_seat0;
 }
 
@@ -2031,11 +2423,57 @@
 }
 
 static char *
+query_ck_for_display_device (GdmManager *manager,
+                             GdmDisplay *display)
+{
+        char    *out;
+        char    *command;
+        char    *display_name = NULL;
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        g_object_get (G_OBJECT (display),
+                      "x11-display-name", &display_name,
+                      NULL);
+
+        error = NULL;
+        command = g_strdup_printf (CONSOLEKIT_DIR "/ck-get-x11-display-device --display %s",
+                                   display_name);
+        g_free (display_name);
+
+        g_debug ("GdmManager: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("GdmManager: Could not run helper %s: %s", command, error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmManager: Got tty: '%s'", out);
+        }
+
+        g_free (command);
+
+        return out;
+}
+
+static char *
 get_display_device (GdmManager *manager,
                     GdmDisplay *display)
 {
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                /* systemd finds the display device out on its own based on the display */
+                return NULL;
+        }
+#endif
+
+        return query_ck_for_display_device (manager, display);
 }
 
 static void
@@ -2045,25 +2483,6 @@
 {
         gboolean fail_if_already_switched = FALSE;
 
-        if (gdm_session_get_display_mode (session) == GDM_SESSION_DISPLAY_MODE_REUSE_VT) {
-                const char *seat_id;
-                char *session_id;
-
-                seat_id = gdm_session_get_display_seat_id (session);
-                if (gdm_get_login_window_session_id (seat_id, &session_id)) {
-                        GdmDisplay *display = gdm_display_store_find (manager->priv->display_store,
-                                                                      lookup_by_session_id,
-                                                                      (gpointer) session_id);
-
-                        if (display != NULL) {
-                                gdm_display_stop_greeter_session (display);
-                                gdm_display_unmanage (display);
-                                gdm_display_finish (display);
-                        }
-                        g_free (session_id);
-                }
-        }
-
         /* There should already be a session running, so jump to its
          * VT. In the event we're already on the right VT, (i.e. user
          * used an unlock screen instead of a user switched login screen),
diff -ruN gdm-3.34.0-orig/daemon/gdm-server.c gdm-3.34.0/daemon/gdm-server.c
--- gdm-3.34.0-orig/daemon/gdm-server.c	2019-08-03 04:44:36.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-server.c	2019-09-17 00:40:47.189446949 +0900
@@ -43,7 +43,9 @@
 #include <linux/vt.h>
 #endif
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
@@ -84,6 +86,7 @@
         char    *auth_file;
 
         guint    child_watch_id;
+        guint    sigusr1_id;
 
         gboolean is_initial;
 };
@@ -114,90 +117,74 @@
 
 G_DEFINE_TYPE (GdmServer, gdm_server, G_TYPE_OBJECT)
 
-char *
-gdm_server_get_display_device (GdmServer *server)
-{
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
-}
-
-static void
-gdm_server_ready (GdmServer *server)
+static char *
+_gdm_server_query_ck_for_display_device (GdmServer *server)
 {
-        g_debug ("GdmServer: Got USR1 from X server - emitting READY");
+        char    *out;
+        char    *command;
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        g_return_val_if_fail (GDM_IS_SERVER (server), NULL);
+
+        error = NULL;
+        command = g_strdup_printf (CONSOLEKIT_DIR "/ck-get-x11-display-device --display %s",
+                                   server->display_name);
+
+        g_debug ("GdmServer: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("Could not run helper: %s", error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmServer: Got tty: '%s'", out);
+        }
 
-        gdm_run_script (GDMCONFDIR "/Init", GDM_USERNAME,
-                        server->display_name,
-                        NULL, /* hostname */
-                        server->auth_file);
+        g_free (command);
 
-        g_signal_emit (server, signals[READY], 0);
+        return out;
 }
 
-static GSList *active_servers;
-static gboolean sigusr1_thread_running;
-static GCond sigusr1_thread_cond;
-static GMutex sigusr1_thread_mutex;
-
-static gboolean
-got_sigusr1 (gpointer user_data)
+char *
+gdm_server_get_display_device (GdmServer *server)
 {
-        GPid pid = GPOINTER_TO_UINT (user_data);
-        GSList *l;
-
-        g_debug ("GdmServer: got SIGUSR1 from PID %d", pid);
-
-        for (l = active_servers; l; l = l->next) {
-                GdmServer *server = l->data;
-
-                if (server->pid == pid)
-                        gdm_server_ready (server);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                /* systemd finds the display device out on its own based on the display */
+                return NULL;
         }
+#endif
 
-        return G_SOURCE_REMOVE;
-}
-
-static gpointer
-sigusr1_thread_main (gpointer user_data)
-{
-        sigset_t sigusr1_mask;
-
-        /* Handle only SIGUSR1 */
-        sigemptyset (&sigusr1_mask);
-        sigaddset (&sigusr1_mask, SIGUSR1);
-        sigprocmask (SIG_SETMASK, &sigusr1_mask, NULL);
-
-        g_mutex_lock (&sigusr1_thread_mutex);
-        sigusr1_thread_running = TRUE;
-        g_cond_signal (&sigusr1_thread_cond);
-        g_mutex_unlock (&sigusr1_thread_mutex);
-
-        /* Spin waiting for a SIGUSR1 */
-        while (TRUE) {
-                siginfo_t info;
-
-                if (sigwaitinfo (&sigusr1_mask, &info) == -1)
-                        continue;
-
-                g_idle_add (got_sigusr1, GUINT_TO_POINTER (info.si_pid));
+        if (server->display_device == NULL) {
+                server->display_device =
+                    _gdm_server_query_ck_for_display_device (server);
+                g_object_notify (G_OBJECT (server), "display-device");
         }
 
-        return NULL;
+        return g_strdup (server->display_device);
 }
 
-static void
-gdm_server_launch_sigusr1_thread_if_needed (void)
+static gboolean
+on_sigusr1 (gpointer user_data)
 {
-        static GThread *sigusr1_thread;
+        GdmServer *server = user_data;
 
-        if (sigusr1_thread == NULL) {
-                sigusr1_thread = g_thread_new ("gdm SIGUSR1 catcher", sigusr1_thread_main, NULL);
+        g_debug ("GdmServer: Got USR1 from X server - emitting READY");
 
-                g_mutex_lock (&sigusr1_thread_mutex);
-                while (!sigusr1_thread_running)
-                        g_cond_wait (&sigusr1_thread_cond, &sigusr1_thread_mutex);
-                g_mutex_unlock (&sigusr1_thread_mutex);
-        }
+        gdm_run_script (GDMCONFDIR "/Init", GDM_USERNAME,
+                        server->display_name,
+                        NULL, /* hostname */
+                        server->auth_file);
+
+        g_signal_emit (server, signals[READY], 0);
+        return FALSE;
 }
 
 static void
@@ -218,7 +205,9 @@
                 debug_options = "";
         }
 
-#define X_SERVER_ARG_FORMAT " -background none -noreset -verbose %s%s"
+        #define X_SERVER_ARG_FORMAT " -background none -noreset -verbose %s%s"
+
+#ifdef WITH_SYSTEMD
 
         /* This is a temporary hack to work around the fact that XOrg
          * currently lacks support for multi-seat hotplugging for
@@ -234,6 +223,10 @@
          * wasn't booted using systemd, or b) the wrapper tool is
          * missing, or c) we are running for the main seat 'seat0'. */
 
+        if (!LOGIND_RUNNING()) {
+                goto fallback;
+        }
+
 #ifdef ENABLE_SYSTEMD_JOURNAL
         /* For systemd, we don't have a log file but instead log to stdout,
            so set it to the xserver's built-in default verbosity */
@@ -256,8 +249,8 @@
         return;
 
 fallback:
+#endif
         server->command = g_strdup_printf (X_SERVER X_SERVER_ARG_FORMAT, verbosity, debug_options);
-
 }
 
 static gboolean
@@ -307,10 +300,12 @@
                 argv[len++] = g_strdup (server->auth_file);
         }
 
-        if (server->display_seat_id != NULL) {
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING() && server->priv->display_seat_id != NULL) {
                 argv[len++] = g_strdup ("-seat");
                 argv[len++] = g_strdup (server->display_seat_id);
         }
+#endif
 
         /* If we were compiled with Xserver >= 1.17 we need to specify
          * '-listen tcp' as the X server dosen't listen on tcp sockets
@@ -655,12 +650,6 @@
         g_object_unref (server);
 }
 
-static void
-prune_active_servers_list (GdmServer *server)
-{
-        active_servers = g_slist_remove (active_servers, server);
-}
-
 static gboolean
 gdm_server_spawn (GdmServer    *server,
                   const char   *vtarg,
@@ -698,15 +687,6 @@
         g_debug ("GdmServer: Starting X server process: %s", freeme);
         g_free (freeme);
 
-        active_servers = g_slist_append (active_servers, server);
-
-        g_object_weak_ref (G_OBJECT (server),
-                           (GWeakNotify)
-                           prune_active_servers_list,
-                           server);
-
-        gdm_server_launch_sigusr1_thread_if_needed ();
-
         if (!g_spawn_async_with_pipes (NULL,
                                        argv,
                                        (char **)env->pdata,
@@ -1043,6 +1023,10 @@
         server->pid = -1;
 
         server->log_dir = g_strdup (LOGDIR);
+
+        server->sigusr1_id = g_unix_signal_add (SIGUSR1,
+                                                      on_sigusr1,
+                                                      server);
 }
 
 static void
@@ -1055,6 +1039,9 @@
 
         server = GDM_SERVER (object);
 
+        if (server->sigusr1_id > 0)
+                g_source_remove (server->sigusr1_id);
+
         gdm_server_stop (server);
 
         g_free (server->command);
diff -ruN gdm-3.34.0-orig/daemon/gdm-session.c gdm-3.34.0/daemon/gdm-session.c
--- gdm-3.34.0-orig/daemon/gdm-session.c	2019-08-29 00:17:33.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-session.c	2019-09-17 00:40:47.193446866 +0900
@@ -3228,6 +3228,10 @@
         g_return_val_if_fail (self != NULL, FALSE);
         g_return_val_if_fail (GDM_IS_SESSION (self), FALSE);
 
+        if (!LOGIND_RUNNING()) {
+                return GDM_SESSION_DISPLAY_MODE_REUSE_VT;
+        }
+
 #ifdef ENABLE_WAYLAND_SUPPORT
         if (gdm_session_is_wayland_session (self)) {
                 bypasses_xsession = TRUE;
@@ -3323,6 +3327,27 @@
 }
 
 void
+gdm_session_select_session_type (GdmSession *self,
+                                 const char *text)
+{
+        GHashTableIter iter;
+        gpointer key, value;
+
+        g_debug ("GdmSession: selecting session type '%s'", text);
+
+        g_hash_table_iter_init (&iter, self->conversations);
+        while (g_hash_table_iter_next (&iter, &key, &value)) {
+                GdmSessionConversation *conversation;
+
+                conversation = (GdmSessionConversation *) value;
+
+                gdm_dbus_worker_call_set_session_type (conversation->worker_proxy,
+                                                       text,
+                                                       NULL, NULL, NULL);
+        }
+}
+
+void
 gdm_session_select_session (GdmSession *self,
                             const char *text)
 {
diff -ruN gdm-3.34.0-orig/daemon/gdm-session.h gdm-3.34.0/daemon/gdm-session.h
--- gdm-3.34.0-orig/daemon/gdm-session.h	2019-08-03 04:44:36.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-session.h	2019-09-17 00:40:47.193446866 +0900
@@ -122,6 +122,8 @@
                                                            const char *text);
 void              gdm_session_select_program              (GdmSession *session,
                                                            const char *command_line);
+void              gdm_session_select_session_type         (GdmSession *session,
+                                                           const char *session_type);
 void              gdm_session_select_session              (GdmSession *session,
                                                            const char *session_name);
 void              gdm_session_select_user                 (GdmSession *session,
diff -ruN gdm-3.34.0-orig/daemon/gdm-session-record.c gdm-3.34.0/daemon/gdm-session-record.c
--- gdm-3.34.0-orig/daemon/gdm-session-record.c	2019-08-14 10:37:16.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-session-record.c	2019-09-17 00:40:47.193446866 +0900
@@ -33,6 +33,16 @@
 #include <utmp.h>
 #endif
 
+#if defined(HAVE_UTIL_H)
+#include <util.h>
+#endif
+
+#if defined(HAVE_GETTTYENT)
+#include <fcntl.h> /* open(2) */
+#include <ttyent.h>
+static int fd = -1;
+#endif
+
 #include <glib.h>
 #include <glib/gi18n.h>
 #include <glib/gstdio.h>
@@ -43,6 +53,9 @@
 #define GDM_BAD_SESSION_RECORDS_FILE "/var/log/btmp"
 #endif
 
+static void write_utmp_login_manually (struct utmp *ut);
+static void write_utmp_logout_manually (char *);
+
 #if !defined(GDM_NEW_SESSION_RECORDS_FILE)
 #    if defined(WTMPX_FILE)
 #        define GDM_NEW_SESSION_RECORDS_FILE WTMPX_FILE
@@ -168,6 +181,84 @@
         g_debug ("using ut_line %.*s", (int) sizeof (u->ut_line), u->ut_line);
 }
 
+static void
+write_utmp_login_manually (struct utmp *ut)
+{
+#if defined(HAVE_GETTTYENT) && defined(HAVE_UTMP_H)
+        UTMP ubuf;
+        int topslot = -1;
+
+        g_debug ("Adding new utmp record");
+
+        /*
+         * First, loop through /etc/ttys, if needed, to initialize the
+         * top of the tty slots, since gdm has no tty.
+         */
+        if (topslot < 0) {
+                topslot = 0;
+                while (getttyent () != (struct ttyent *) NULL)
+                        topslot++;
+        }
+        if ((topslot < 0) || ((fd < 0) &&
+            (fd = open (_PATH_UTMP, O_RDWR|O_CREAT, 0644)) < 0))
+                return;
+
+        /*
+         * Now find a slot that's not in use...
+         */
+        (void) lseek (fd, (off_t) (topslot * sizeof (struct utmp)), SEEK_SET);
+
+        while (1) {
+                if (read (fd, &ubuf, sizeof (struct utmp)) ==
+                    sizeof (struct utmp)) {
+                        if (!ubuf.ut_name[0]) {
+                                (void) lseek (fd, -(off_t) sizeof (struct utmp),
+                                    SEEK_CUR);
+                                break;
+                        }
+                        topslot++;
+                } else {
+                        (void) lseek (fd, (off_t) (topslot *
+                            sizeof (struct utmp)), SEEK_SET);
+                        break;
+                }
+        }
+
+        (void) write (fd, ut, sizeof (struct utmp));
+#endif
+}
+
+static void
+write_utmp_logout_manually (char *line)
+{
+#if defined(HAVE_GETTTYENT) && defined(HAVE_UTMP_H)
+        int rval = 1;
+        struct timeval tv;
+        UTMP ut;
+
+        g_debug ("Removing utmp record");
+
+        if (fd >= 0) {
+            (void) lseek (fd, 0, SEEK_SET);
+            while (read (fd, &ut, sizeof (struct utmp)) == sizeof (struct utmp)) {
+                    if (!ut.ut_name[0] ||
+                        strncmp (ut.ut_line, line, UT_LINESIZE))
+                            continue;
+                    bzero (ut.ut_name, UT_NAMESIZE);
+                    bzero (ut.ut_host, UT_HOSTSIZE);
+                    gettimeofday (&tv, NULL);
+                    ut.ut_time = tv.tv_sec;
+                    (void) lseek (fd, -(off_t) sizeof (struct utmp), SEEK_CUR);
+                    (void) write (fd, &ut, sizeof (struct utmp));
+                    rval = 0;
+            }
+        }
+
+        if (rval != 0)
+            g_debug ("Failed to remove utmp record");
+#endif
+}
+
 void
 gdm_session_record_login (GPid                  session_pid,
                           const char           *user_name,
@@ -214,8 +305,9 @@
         setutxent();
         pututxline (&session_record);
         endutxent();
-#elif defined(HAVE_LOGIN)
-	login (&session_record);
+#else
+        if (strcmp (session_record.ut_name, "(unknown)") != 0)
+	    write_utmp_login_manually (&session_record);
 #endif
 }
 
@@ -259,8 +351,8 @@
         setutxent();
         pututxline (&session_record);
         endutxent();
-#elif defined(HAVE_LOGOUT)
-        logout (session_record.ut_line);
+#else
+        write_utmp_logout_manually (session_record.ut_line);
 #endif
 }
 
diff -ruN gdm-3.34.0-orig/daemon/gdm-session-worker.c gdm-3.34.0/daemon/gdm-session-worker.c
--- gdm-3.34.0-orig/daemon/gdm-session-worker.c	2019-09-05 04:22:28.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-session-worker.c	2019-09-17 00:40:47.193446866 +0900
@@ -28,9 +28,11 @@
 #include <string.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#ifdef WITH_SYSTEMD
 #include <sys/ioctl.h>
 #include <sys/vt.h>
 #include <sys/kd.h>
+#endif
 #include <errno.h>
 #include <grp.h>
 #include <pwd.h>
@@ -49,7 +51,9 @@
 
 #include <X11/Xauth.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
@@ -93,7 +97,7 @@
 #endif
 
 #ifndef GDM_SESSION_DEFAULT_PATH
-#define GDM_SESSION_DEFAULT_PATH "/usr/local/bin:/usr/bin:/bin"
+#define GDM_SESSION_DEFAULT_PATH "${LOCALBASE}/bin:/usr/bin:/bin"
 #endif
 
 #ifndef GDM_SESSION_ROOT_UID
@@ -125,6 +129,10 @@
 
         int               exit_code;
 
+#ifdef WITH_CONSOLE_KIT
+        char             *session_cookie;
+#endif
+
         pam_handle_t     *pam_handle;
 
         GPid              child_pid;
@@ -139,6 +147,7 @@
         char             *hostname;
         char             *username;
         char             *log_file;
+        char             *session_type;
         char             *session_id;
         uid_t             uid;
         gid_t             gid;
@@ -214,6 +223,204 @@
                                                 worker_interface_init)
                          G_ADD_PRIVATE (GdmSessionWorker))
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+open_ck_session (GdmSessionWorker  *worker)
+{
+        GDBusConnection  *system_bus;
+        GVariantBuilder   builder;
+        GVariant         *parameters;
+        GVariant         *in_args;
+        struct passwd    *pwent;
+        GVariant         *reply;
+        GError           *error = NULL;
+        const char       *display_name;
+        const char       *display_device;
+        const char       *display_hostname;
+        const char       *session_type;
+        gint32            uid;
+
+        g_assert (worker->priv->session_cookie == NULL);
+
+        if (worker->priv->x11_display_name != NULL) {
+                display_name = worker->priv->x11_display_name;
+        } else {
+                display_name = "";
+        }
+        if (worker->priv->hostname != NULL) {
+                display_hostname = worker->priv->hostname;
+        } else {
+                display_hostname = "";
+        }
+        if (worker->priv->display_device != NULL) {
+                display_device = worker->priv->display_device;
+        } else {
+                display_device = "";
+        }
+
+        if (worker->priv->session_type != NULL) {
+                session_type = worker->priv->session_type;
+        } else {
+                session_type = "";
+        }
+
+        g_assert (worker->priv->username != NULL);
+
+        gdm_get_pwent_for_name (worker->priv->username, &pwent);
+        if (pwent == NULL) {
+                goto out;
+        }
+
+        uid = (gint32) pwent->pw_uid;
+
+        error = NULL;
+        system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+
+        if (system_bus == NULL) {
+                g_warning ("Couldn't create connection to system bus: %s",
+                           error->message);
+
+                g_error_free (error);
+                goto out;
+        }
+
+        g_variant_builder_init (&builder, G_VARIANT_TYPE ("a(sv)"));
+        g_variant_builder_add_parsed (&builder, "('unix-user', <%i>)", uid);
+        g_variant_builder_add_parsed (&builder, "('x11-display-device', <%s>)", display_device);
+        g_variant_builder_add_parsed (&builder, "('x11-display', <%s>)", display_name);
+        g_variant_builder_add_parsed (&builder, "('remote-host-name', <%s>)", display_hostname);
+        g_variant_builder_add_parsed (&builder, "('is-local', <%b>)", worker->priv->display_is_local);
+        g_variant_builder_add_parsed (&builder, "('session-type', <%s>)", session_type);
+
+        parameters = g_variant_builder_end (&builder);
+        in_args = g_variant_new_tuple (&parameters, 1);
+
+        reply = g_dbus_connection_call_sync (system_bus,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "OpenSessionWithParameters",
+                                             in_args,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+
+        if (! reply) {
+                g_warning ("%s\n", error->message);
+                g_clear_error (&error);
+                goto out;
+        }
+
+        g_variant_get (reply, "(s)", &worker->priv->session_cookie);
+
+        g_variant_unref (reply);
+
+out:
+        return worker->priv->session_cookie != NULL;
+}
+
+static void
+close_ck_session (GdmSessionWorker *worker)
+{
+        GDBusConnection  *system_bus;
+        GVariant         *reply;
+        GError           *error = NULL;
+        gboolean          was_closed;
+
+        if (worker->priv->session_cookie == NULL) {
+                return;
+        }
+
+        error = NULL;
+        system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+
+        if (system_bus == NULL) {
+                g_warning ("Couldn't create connection to system bus: %s",
+                           error->message);
+
+                g_error_free (error);
+                goto out;
+        }
+
+        reply = g_dbus_connection_call_sync (system_bus,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "CloseSession",
+                                             g_variant_new ("(s)", worker->priv->session_cookie),
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+
+        if (! reply) {
+                g_warning ("%s", error->message);
+                g_clear_error (&error);
+                goto out;
+        }
+
+        g_variant_get (reply, "(b)", &was_closed);
+
+        if (!was_closed) {
+                g_warning ("Unable to close ConsoleKit session");
+        }
+
+        g_variant_unref (reply);
+
+out:
+        g_clear_pointer (&worker->priv->session_cookie,
+                         (GDestroyNotify) g_free);
+}
+
+static char *
+get_ck_session_id (GdmSessionWorker *worker)
+{
+        GDBusConnection  *system_bus;
+        GVariant         *reply;
+        GError           *error = NULL;
+        char             *session_id = NULL;
+
+        error = NULL;
+        system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+
+        if (system_bus == NULL) {
+                g_warning ("Couldn't create connection to system bus: %s",
+                           error->message);
+
+                g_error_free (error);
+                goto out;
+        }
+
+        reply = g_dbus_connection_call_sync (system_bus,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForCookie",
+                                             g_variant_new ("(s)", worker->priv->session_cookie),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+
+        if (reply == NULL) {
+                g_warning ("%s", error->message);
+                g_clear_error (&error);
+                goto out;
+        }
+
+        g_variant_get (reply, "(o)", &session_id);
+
+        g_variant_unref (reply);
+
+out:
+        return session_id;
+}
+#endif
+
 /* adapted from glib script_execute */
 static void
 script_execute (const gchar *file,
@@ -665,7 +872,9 @@
         char    *user_answer;
         gboolean res;
         char    *utf8_msg;
+#ifdef PAM_RADIO_TYPE
         char	*msg;
+#endif
 
         if (response != NULL) {
                 *response = NULL;
@@ -869,6 +1078,7 @@
         worker->priv->auditor = NULL;
 }
 
+#ifdef WITH_SYSTEMD
 static void
 on_release_display (int signal)
 {
@@ -1011,6 +1221,7 @@
 
         close (active_vt_tty_fd);
 }
+#endif
 
 static void
 gdm_session_worker_set_state (GdmSessionWorker      *worker,
@@ -1052,11 +1263,13 @@
 
         gdm_session_worker_stop_auditor (worker);
 
+#ifdef WITH_SYSTEMD
         if (g_strcmp0 (worker->priv->display_seat_id, "seat0") == 0) {
                 if (worker->priv->login_vt != worker->priv->session_vt) {
                         jump_to_vt (worker, worker->priv->login_vt);
                 }
         }
+#endif
 
         worker->priv->login_vt = 0;
         worker->priv->session_vt = 0;
@@ -1107,6 +1320,7 @@
 }
 #endif
 
+#ifdef WITH_SYSTEMD
 static gboolean
 ensure_login_vt (GdmSessionWorker *worker)
 {
@@ -1132,6 +1346,7 @@
         close (fd);
         return got_login_vt;
 }
+#endif
 
 static gboolean
 gdm_session_worker_initialize_pam (GdmSessionWorker   *worker,
@@ -1148,7 +1363,6 @@
 {
         struct pam_conv        pam_conversation;
         int                    error_code;
-        char tty_string[256];
 
         g_assert (worker->priv->pam_handle == NULL);
 
@@ -1215,10 +1429,12 @@
                 }
         }
 
+#ifdef WITH_SYSTEMD
         /* set seat ID */
-        if (seat_id != NULL && seat_id[0] != '\0') {
+        if (seat_id != NULL && seat_id[0] != '\0' && LOGIND_RUNNING()) {
                 gdm_session_worker_set_environment_variable (worker, "XDG_SEAT", seat_id);
         }
+#endif
 
         if (strcmp (service, "gdm-launch-environment") == 0) {
                 gdm_session_worker_set_environment_variable (worker, "XDG_SESSION_CLASS", "greeter");
@@ -1227,6 +1443,7 @@
         g_debug ("GdmSessionWorker: state SETUP_COMPLETE");
         gdm_session_worker_set_state (worker, GDM_SESSION_WORKER_STATE_SETUP_COMPLETE);
 
+#ifdef WITH_SYSTEMD
         /* Temporarily set PAM_TTY with the currently active VT (login screen) 
            PAM_TTY will be reset with the users VT right before the user session is opened */
         if (ensure_login_vt (worker)) {
@@ -1235,6 +1452,7 @@
         }
         if (!display_is_local)
                 worker->priv->password_is_required = TRUE;
+#endif
 
  out:
         if (error_code != PAM_SUCCESS) {
@@ -1530,7 +1748,7 @@
                 if (passwd_entry->pw_shell != NULL && passwd_entry->pw_shell[0] != '\0') {
                         *shellp = g_strdup (passwd_entry->pw_shell);
                 } else {
-                        *shellp = g_strdup ("/bin/bash");
+                        *shellp = g_strdup ("/bin/ksh");
                 }
         }
         ret = TRUE;
@@ -1783,6 +2001,26 @@
         return (const char * const *) pam_getenvlist (worker->priv->pam_handle);
 }
 
+#ifdef WITH_CONSOLE_KIT
+static void
+register_ck_session (GdmSessionWorker *worker)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return;
+        }
+#endif
+
+        open_ck_session (worker);
+
+        if (worker->priv->session_cookie != NULL) {
+                gdm_session_worker_set_environment_variable (worker,
+                                                             "XDG_SESSION_COOKIE",
+                                                             worker->priv->session_cookie);
+        }
+}
+#endif
+
 static gboolean
 run_script (GdmSessionWorker *worker,
             const char       *dir)
@@ -1813,6 +2051,9 @@
                  : WIFSIGNALED (status) ? WTERMSIG (status)
                  : -1);
 
+#ifdef WITH_CONSOLE_KIT
+        close_ck_session (worker);
+#endif
 
         gdm_session_worker_uninitialize_pam (worker, PAM_SUCCESS);
 
@@ -2003,6 +2244,7 @@
 
         error_code = PAM_SUCCESS;
 
+#ifdef WITH_SYSTEMD
         /* If we're in new vt mode, jump to the new vt now. There's no need to jump for
          * the other two modes: in the logind case, the session will activate itself when
          * ready, and in the reuse server case, we're already on the correct VT. */
@@ -2011,6 +2253,7 @@
                         jump_to_vt (worker, worker->priv->session_vt);
                 }
         }
+#endif
 
         if (!worker->priv->is_program_session && !run_script (worker, GDMCONFDIR "/PostLogin")) {
                 g_set_error (error,
@@ -2073,6 +2316,7 @@
                         _exit (EXIT_FAILURE);
                 }
 
+#ifdef WITH_SYSTEMD
                 /* Take control of the tty
                  */
                 if (needs_controlling_terminal) {
@@ -2080,6 +2324,7 @@
                                 g_debug ("GdmSessionWorker: could not take control of tty: %m");
                         }
                 }
+#endif
 
 #ifdef HAVE_LOGINCAP
                 if (setusercontext (NULL, passwd_entry, passwd_entry->pw_uid, LOGIN_SETALL) < 0) {
@@ -2211,11 +2456,13 @@
         return TRUE;
 }
 
+#ifdef WITH_SYSTEMD
 static gboolean
 set_up_for_new_vt (GdmSessionWorker *worker)
 {
         int fd;
         char vt_string[256], tty_string[256];
+        struct vt_stat vt_state = { 0 };
         int session_vt = 0;
 
         fd = open ("/dev/tty0", O_RDWR | O_NOCTTY);
@@ -2225,6 +2472,11 @@
                 return FALSE;
         }
 
+        if (ioctl (fd, VT_GETSTATE, &vt_state) < 0) {
+                g_debug ("GdmSessionWorker: couldn't get current VT: %m");
+                goto fail;
+        }
+
         if (worker->priv->display_is_initial) {
                 session_vt = GDM_INITIAL_VT;
         } else {
@@ -2234,6 +2486,7 @@
                 }
         }
 
+        worker->priv->login_vt = vt_state.v_active;
         worker->priv->session_vt = session_vt;
 
         close (fd);
@@ -2296,6 +2549,7 @@
         close (fd);
         return FALSE;
 }
+#endif
 
 static gboolean
 set_up_for_current_vt (GdmSessionWorker  *worker,
@@ -2363,12 +2617,14 @@
          }
 #endif
 
+#ifdef WITH_SYSTEMD
         if (g_strcmp0 (worker->priv->display_seat_id, "seat0") == 0) {
                 g_debug ("GdmSessionWorker: setting XDG_VTNR to current vt");
                 set_xdg_vtnr_to_current_vt (worker);
         } else {
                 g_debug ("GdmSessionWorker: not setting XDG_VTNR since not seat0");
         }
+#endif
 
         return TRUE;
 out:
@@ -2394,6 +2650,7 @@
                 break;
         case GDM_SESSION_DISPLAY_MODE_NEW_VT:
         case GDM_SESSION_DISPLAY_MODE_LOGIND_MANAGED:
+#ifdef WITH_SYSTEMD
                 if (!set_up_for_new_vt (worker)) {
                         g_set_error (error,
                                      GDM_SESSION_WORKER_ERROR,
@@ -2401,6 +2658,7 @@
                                      "Unable to open VT");
                         return FALSE;
                 }
+#endif
                 break;
         }
 
@@ -2423,7 +2681,17 @@
         g_debug ("GdmSessionWorker: state SESSION_OPENED");
         gdm_session_worker_set_state (worker, GDM_SESSION_WORKER_STATE_SESSION_OPENED);
 
+#ifdef WITH_SYSTEMD
         session_id = gdm_session_worker_get_environment_variable (worker, "XDG_SESSION_ID");
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        register_ck_session (worker);
+
+        if (session_id == NULL) {
+                session_id = get_ck_session_id (worker);
+        }
+#endif
 
         if (session_id != NULL) {
                 g_free (worker->priv->session_id);
@@ -2532,6 +2800,19 @@
 }
 
 static gboolean
+gdm_session_worker_handle_set_session_type (GdmDBusWorker         *object,
+                                            GDBusMethodInvocation *invocation,
+                                            const char            *session_type)
+{
+        GdmSessionWorker *worker = GDM_SESSION_WORKER (object);
+        g_debug ("GdmSessionWorker: session type set to %s", session_type);
+        g_free (worker->priv->session_type);
+        worker->priv->session_type = g_strdup (session_type);
+        gdm_dbus_worker_complete_set_session_type (object, invocation);
+        return TRUE;
+}
+
+static gboolean
 gdm_session_worker_handle_set_session_display_mode (GdmDBusWorker         *object,
                                                     GDBusMethodInvocation *invocation,
                                                     const char            *str)
@@ -2958,6 +3239,7 @@
         return TRUE;
 }
 
+#ifdef SUPPORTS_PAM_EXTENSIONS
 static char **
 filter_extensions (const char * const *extensions)
 {
@@ -2983,6 +3265,7 @@
 
         return filtered_extensions;
 }
+#endif
 
 static gboolean
 gdm_session_worker_handle_initialize (GdmDBusWorker         *object,
@@ -3002,8 +3285,10 @@
         while (g_variant_iter_loop (&iter, "{sv}", &key, &value)) {
                 if (g_strcmp0 (key, "service") == 0) {
                         worker->priv->service = g_variant_dup_string (value, NULL);
+#ifdef SUPPORTS_PAM_EXTENSIONS
                 } else if (g_strcmp0 (key, "extensions") == 0) {
                         worker->priv->extensions = filter_extensions (g_variant_get_strv (value, NULL));
+#endif
                 } else if (g_strcmp0 (key, "username") == 0) {
                         worker->priv->username = g_variant_dup_string (value, NULL);
                 } else if (g_strcmp0 (key, "is-program-session") == 0) {
@@ -3443,6 +3728,7 @@
         interface->handle_open = gdm_session_worker_handle_open;
         interface->handle_set_language_name = gdm_session_worker_handle_set_language_name;
         interface->handle_set_session_name = gdm_session_worker_handle_set_session_name;
+        interface->handle_set_session_type = gdm_session_worker_handle_set_session_type;
         interface->handle_set_session_display_mode = gdm_session_worker_handle_set_session_display_mode;
         interface->handle_set_environment_variable = gdm_session_worker_handle_set_environment_variable;
         interface->handle_start_program = gdm_session_worker_handle_start_program;
diff -ruN gdm-3.34.0-orig/daemon/gdm-session-worker-job.c gdm-3.34.0/daemon/gdm-session-worker-job.c
--- gdm-3.34.0-orig/daemon/gdm-session-worker-job.c	2019-08-03 04:44:36.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-session-worker-job.c	2019-09-17 00:40:47.193446866 +0900
@@ -36,7 +36,9 @@
 #include <sys/prctl.h>
 #endif
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
diff -ruN gdm-3.34.0-orig/daemon/gdm-session-worker.xml gdm-3.34.0/daemon/gdm-session-worker.xml
--- gdm-3.34.0-orig/daemon/gdm-session-worker.xml	2019-08-03 04:44:36.000000000 +0900
+++ gdm-3.34.0/daemon/gdm-session-worker.xml	2019-09-17 00:40:47.197446784 +0900
@@ -13,6 +13,9 @@
     <method name="SetSessionName">
       <arg name="session_name" direction="in" type="s" />
     </method>
+    <method name="SetSessionType">
+      <arg name="session_type" direction="in" type="s"/>
+    </method>
     <method name="SetSessionDisplayMode">
       <arg name="mode" direction="in" type="s"/>
     </method>
diff -ruN gdm-3.34.0-orig/daemon/main.c gdm-3.34.0/daemon/main.c
--- gdm-3.34.0-orig/daemon/main.c	2019-02-22 04:44:14.000000000 +0900
+++ gdm-3.34.0/daemon/main.c	2019-09-17 00:40:47.197446784 +0900
@@ -289,19 +289,6 @@
         return debug;
 }
 
-/* SIGUSR1 is used by the X server to tell us that we're ready, so
- * block it. We'll unblock it in the worker thread in gdm-server.c
- */
-static void
-block_sigusr1 (void)
-{
-        sigset_t mask;
-
-        sigemptyset (&mask);
-        sigaddset (&mask, SIGUSR1);
-        sigprocmask (SIG_BLOCK, &mask, NULL);
-}
-
 int
 main (int    argc,
       char **argv)
@@ -321,8 +308,6 @@
                 { NULL }
         };
 
-        block_sigusr1 ();
-
         bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
         textdomain (GETTEXT_PACKAGE);
         setlocale (LC_ALL, "");
diff -ruN gdm-3.34.0-orig/daemon/Makefile.am gdm-3.34.0/daemon/Makefile.am
--- gdm-3.34.0-orig/daemon/Makefile.am	2019-08-14 04:42:23.000000000 +0900
+++ gdm-3.34.0/daemon/Makefile.am	2019-09-17 00:40:47.197446784 +0900
@@ -21,6 +21,7 @@
 	-DGDM_SCREENSHOT_DIR=\"$(GDM_SCREENSHOT_DIR)\"		\
 	-DGDM_CACHE_DIR=\""$(localstatedir)/cache/gdm"\"	\
 	-DGDM_SESSION_DEFAULT_PATH=\"$(GDM_SESSION_DEFAULT_PATH)\" \
+	-DCONSOLEKIT_DIR=\"$(CONSOLEKIT_DIR)\" \
 	$(DISABLE_DEPRECATED_CFLAGS)			\
 	$(DAEMON_CFLAGS)				\
 	$(XLIB_CFLAGS)					\
@@ -278,6 +279,11 @@
 	$(XDMCP_SOURCES)	\
 	$(NULL)
 
+CONSOLE_KIT_SOURCES = 		\
+	$(NULL)
+
+EXTRA_gdm_SOURCES += $(CONSOLE_KIT_SOURCES)
+
 gdm_LDADD = \
 	$(top_builddir)/common/libgdmcommon.la	\
 	$(XLIB_LIBS)				\
@@ -289,6 +295,10 @@
 	$(EXTRA_DAEMON_LIBS)			\
 	$(NULL)
 
+if WITH_CONSOLE_KIT
+gdm_SOURCES += $(CONSOLE_KIT_SOURCES)
+endif
+
 CLEANFILES =					\
 	gdm-display-glue.c			\
 	gdm-local-display-factory-glue.c	\
diff -ruN gdm-3.34.0-orig/data/Init.in gdm-3.34.0/data/Init.in
--- gdm-3.34.0-orig/data/Init.in	2019-02-22 04:44:14.000000000 +0900
+++ gdm-3.34.0/data/Init.in	2019-09-17 00:40:47.197446784 +0900
@@ -6,6 +6,15 @@
 PATH="@X_PATH@:$PATH"
 OLD_IFS=$IFS
 
+# enhance fade in look
+xsetroot -solid black
+
+# wait for ttys to be initialized
+while ! pgrep -qf "^/usr/libexec/getty "; do
+	sleep 1
+	[ $((i++)) -ge 10 ] && break
+done
+
 gdmwhich () {
   COMMAND="$1"
   OUTPUT=
@@ -86,4 +95,14 @@
   fi
 fi
 
+# /etc/X11/xenodm/GiveConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown _gdm /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown _gdm /dev/drmR128
+fi
+# XXX OpenBSD needs an implementation of XDG_RUNTIME_DIR
+rm -rf /var/db/gdm/.cache/gnome-shell/runtime-state-*
+
 exit 0
diff -ruN gdm-3.34.0-orig/data/Makefile.am gdm-3.34.0/data/Makefile.am
--- gdm-3.34.0-orig/data/Makefile.am	2019-08-14 04:42:23.000000000 +0900
+++ gdm-3.34.0/data/Makefile.am	2019-09-17 00:40:47.197446784 +0900
@@ -220,6 +220,7 @@
 Xsession: $(srcdir)/Xsession.in
 	sed	-e 's,[@]XSESSION_SHELL[@],$(XSESSION_SHELL),g' \
 		-e 's,[@]libexecdir[@],$(libexecdir),g' \
+		-e 's,[@]X_PATH[@],$(X_PATH),g' \
 		<$(srcdir)/Xsession.in >Xsession
 Xsession_files += Xsession
 CLEANFILES += Xsession
diff -ruN gdm-3.34.0-orig/data/PostSession.in gdm-3.34.0/data/PostSession.in
--- gdm-3.34.0-orig/data/PostSession.in	2018-10-13 06:05:26.000000000 +0900
+++ gdm-3.34.0/data/PostSession.in	2019-09-17 00:40:47.197446784 +0900
@@ -1,3 +1,11 @@
 #!/bin/sh
 
+# /etc/X11/xenodm/TakeConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown root /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown root /dev/drmR128
+fi
+
 exit 0
diff -ruN gdm-3.34.0-orig/data/PreSession.in gdm-3.34.0/data/PreSession.in
--- gdm-3.34.0-orig/data/PreSession.in	2018-10-13 06:05:26.000000000 +0900
+++ gdm-3.34.0/data/PreSession.in	2019-09-17 00:40:47.197446784 +0900
@@ -7,3 +7,11 @@
 # Note that output goes into the .xsession-errors file for easy debugging
 #
 PATH="@X_PATH@:$PATH"
+
+# /etc/X11/xenodm/GiveConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown $USER /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown $USER /dev/drmR128
+fi
diff -ruN gdm-3.34.0-orig/libgdm/gdm-user-switching.c gdm-3.34.0/libgdm/gdm-user-switching.c
--- gdm-3.34.0-orig/libgdm/gdm-user-switching.c	2019-08-14 04:42:23.000000000 +0900
+++ gdm-3.34.0/libgdm/gdm-user-switching.c	2019-09-17 00:40:47.197446784 +0900
@@ -31,12 +31,25 @@
 #include <glib-object.h>
 #include <gio/gio.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "common/gdm-common.h"
 #include "gdm-user-switching.h"
 #include "gdm-client.h"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
 static gboolean
 create_transient_display (GDBusConnection *connection,
                           GCancellable    *cancellable,
@@ -67,12 +80,304 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
+
+static gboolean
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
+gboolean
+activate_session_id_for_ck (GDBusConnection *connection,
+                            GCancellable    *cancellable,
+                            const char      *seat_id,
+                            const char      *session_id,
+                            GError         **error)
+{
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                g_prefix_error (error, _("Unable to activate session: "));
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+        gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
 static gboolean
-activate_session_id (GDBusConnection  *connection,
-                     GCancellable     *cancellable,
-                     const char       *seat_id,
-                     const char       *session_id,
-                     GError          **error)
+goto_login_session_for_ck (GDBusConnection  *connection,
+                           GCancellable     *cancellable,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, cancellable, seat_id, session_id, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, cancellable, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+
+gboolean
+activate_session_id_for_systemd (GDBusConnection  *connection,
+                                 GCancellable     *cancellable,
+                                 const char       *seat_id,
+                                 const char       *session_id,
+                                 GError          **error)
 {
         GVariant *reply;
 
@@ -97,8 +402,8 @@
 }
 
 static gboolean
-get_login_window_session_id (const char  *seat_id,
-                             char       **session_id)
+get_login_window_session_id_for_systemd (const char  *seat_id,
+                                         char       **session_id)
 {
         gboolean   ret;
         int        res, i;
@@ -182,9 +487,9 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
-                    GCancellable     *cancellable,
-                    GError          **error)
+goto_login_session_for_systemd (GDBusConnection  *connection,
+                                GCancellable     *cancellable,
+                                GError          **error)
 {
         gboolean        ret;
         int             res;
@@ -236,9 +541,9 @@
                 return FALSE;
         }
 
-        res = get_login_window_session_id (seat_id, &session_id);
+        res = get_login_window_session_id_for_systemd (seat_id, &session_id);
         if (res && session_id != NULL) {
-                res = activate_session_id (connection, cancellable, seat_id, session_id, error);
+                res = activate_session_id_for_systemd (connection, cancellable, seat_id, session_id, error);
 
                 if (res) {
                         ret = TRUE;
@@ -257,10 +562,11 @@
 
         return ret;
 }
+#endif
 
 gboolean
 gdm_goto_login_session_sync (GCancellable  *cancellable,
-                             GError       **error)
+			     GError       **error)
 {
         GDBusConnection *connection;
         gboolean retval;
@@ -269,8 +575,23 @@
         if (!connection)
                 return FALSE;
 
-        retval = goto_login_session (connection, cancellable, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                retval = goto_login_session_for_systemd (connection,
+                                                         cancellable,
+                                                         error);
+
+                g_object_unref (connection);
+                return retval;
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        retval = goto_login_session_for_ck (connection, cancellable, error);
 
         g_object_unref (connection);
         return retval;
+#else
+        return FALSE;
+#endif
 }
diff -ruN gdm-3.34.0-orig/Makefile.am gdm-3.34.0/Makefile.am
--- gdm-3.34.0-orig/Makefile.am	2019-08-03 04:44:35.000000000 +0900
+++ gdm-3.34.0/Makefile.am	2019-09-17 00:40:47.197446784 +0900
@@ -7,7 +7,6 @@
 	daemon 			\
 	libgdm 			\
 	utils 			\
-	pam_gdm			\
 	po 			\
 	tests 			\
 	$(NULL)
