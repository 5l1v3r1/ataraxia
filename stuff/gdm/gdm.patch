--- gdm-3.34.1-orig/Makefile.am
+++ gdm-3.34.1/Makefile.am
@@ -7,7 +7,6 @@
 	daemon 			\
 	libgdm 			\
 	utils 			\
-	pam_gdm			\
 	po 			\
 	tests 			\
 	$(NULL)
--- gdm-3.34.1-orig/common/gdm-address.c
+++ gdm-3.34.1/common/gdm-address.c
@@ -29,6 +29,8 @@
 #include <stropts.h>
 #endif
 #include <string.h>
+#include <sys/types.h>
+#include <sys/param.h>
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -37,7 +39,6 @@
 #endif
 #include <netdb.h>
 #include <sys/ioctl.h>
-#include <net/if.h>
 
 #ifndef G_OS_WIN32
 #include <sys/select.h>
@@ -47,6 +48,7 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #endif
+#include <net/if.h>
 
 #include <glib-object.h>
 
--- gdm-3.34.1-orig/common/gdm-common.c
+++ gdm-3.34.1/common/gdm-common.c
@@ -36,12 +36,25 @@
 
 #include "gdm-common.h"
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #define GDM_DBUS_NAME                            "org.gnome.DisplayManager"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_PATH      "/org/gnome/DisplayManager/LocalDisplayFactory"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_INTERFACE "org.gnome.DisplayManager.LocalDisplayFactory"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
 G_DEFINE_QUARK (gdm-common-error, gdm_common_error);
 
 gboolean
@@ -352,8 +365,87 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
 gboolean
-gdm_activate_session_by_id (GDBusConnection *connection,
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
+gboolean
+activate_session_id_for_ck (GDBusConnection *connection,
                             const char      *seat_id,
                             const char      *session_id)
 {
@@ -361,6 +453,217 @@
         GVariant *reply;
 
         reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to activate session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+       gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
+static gboolean
+goto_login_session_for_ck (GDBusConnection  *connection,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_COMMON_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_COMMON_ERROR, 1, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, seat_id, session_id);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+
+gboolean
+activate_session_id_for_systemd (GDBusConnection *connection,
+                                 const char      *seat_id,
+                                 const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
                                              "org.freedesktop.login1.Manager",
@@ -382,8 +685,8 @@
 }
 
 gboolean
-gdm_get_login_window_session_id (const char  *seat_id,
-                                 char       **session_id)
+get_login_window_session_id_for_systemd (const char  *seat_id,
+                                         char       **session_id)
 {
         gboolean   ret;
         int        res, i;
@@ -476,15 +779,14 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
-                    GError          **error)
+goto_login_session_for_systemd (GDBusConnection  *connection,
+                                GError          **error)
 {
         gboolean        ret;
         int             res;
         char           *our_session;
         char           *session_id;
         char           *seat_id;
-        GError         *local_error = NULL;
 
         ret = FALSE;
         session_id = NULL;
@@ -497,8 +799,10 @@
          * since the data allocated is from libsystemd-logind, which
          * does not use GLib's g_malloc (). */
 
-        if (!gdm_find_display_session_for_uid (getuid (), &our_session, &local_error)) {
-                g_propagate_prefixed_error (error, local_error, _("Could not identify the current session: "));
+        res = sd_pid_get_session (0, &our_session);
+        if (res < 0) {
+                g_debug ("failed to determine own session: %s", strerror (-res));
+                g_set_error (error, GDM_COMMON_ERROR, 0, _("Could not identify the current session."));
 
                 return FALSE;
         }
@@ -530,9 +834,9 @@
                 return FALSE;
         }
 
-        res = gdm_get_login_window_session_id (seat_id, &session_id);
+        res = get_login_window_session_id_for_systemd (seat_id, &session_id);
         if (res && session_id != NULL) {
-                res = gdm_activate_session_by_id (connection, seat_id, session_id);
+                res = activate_session_id_for_systemd (connection, seat_id, session_id);
 
                 if (res) {
                         ret = TRUE;
@@ -551,6 +855,7 @@
 
         return ret;
 }
+#endif
 
 gboolean
 gdm_goto_login_session (GError **error)
@@ -566,7 +871,17 @@
                 return FALSE;
         }
 
-        return goto_login_session (connection, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return goto_login_session_for_systemd (connection, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return goto_login_session_for_ck (connection, error);
+#else
+        return FALSE;
+#endif
 }
 
 static void
@@ -841,114 +1156,4 @@
                 }
         }
         return g_string_free (s, FALSE);
-}
-
-static gboolean
-_systemd_session_is_graphical (const char *session_id)
-{
-        const gchar * const graphical_session_types[] = { "wayland", "x11", "mir", NULL };
-        int saved_errno;
-        g_autofree gchar *type = NULL;
-
-        saved_errno = sd_session_get_type (session_id, &type);
-        if (saved_errno < 0) {
-                g_warning ("Couldn't get type for session '%s': %s",
-                           session_id,
-                           g_strerror (-saved_errno));
-                return FALSE;
-        }
-
-        if (!g_strv_contains (graphical_session_types, type)) {
-                g_debug ("Session '%s' is not a graphical session (type: '%s')",
-                         session_id,
-                         type);
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-_systemd_session_is_active (const char *session_id)
-{
-        const gchar * const active_states[] = { "active", "online", NULL };
-        int saved_errno;
-        g_autofree gchar *state = NULL;
-
-        /*
-         * display sessions can be 'closing' if they are logged out but some
-         * processes are lingering; we shouldn't consider these (this is
-         * checking for a race condition since we specified
-         * GDM_SYSTEMD_SESSION_REQUIRE_ONLINE)
-         */
-        saved_errno = sd_session_get_state (session_id, &state);
-        if (saved_errno < 0) {
-                g_warning ("Couldn't get state for session '%s': %s",
-                           session_id,
-                           g_strerror (-saved_errno));
-                return FALSE;
-        }
-
-        if (!g_strv_contains (active_states, state)) {
-                g_debug ("Session '%s' is not active or online", session_id);
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-gboolean
-gdm_find_display_session_for_uid (const uid_t uid,
-                                  char      **out_session_id,
-                                  GError    **error)
-{
-        char *local_session_id = NULL;
-        g_auto(GStrv) sessions = NULL;
-        int n_sessions;
-
-        g_return_val_if_fail (out_session_id != NULL, FALSE);
-
-        g_debug ("Finding a graphical session for user %d", uid);
-
-        n_sessions = sd_uid_get_sessions (uid,
-                                          GDM_SYSTEMD_SESSION_REQUIRE_ONLINE,
-                                          &sessions);
-
-        if (n_sessions < 0) {
-                g_set_error (error,
-                             GDM_COMMON_ERROR,
-                             0,
-                             "Failed to get sessions for user %d",
-                             uid);
-                return FALSE;
-        }
-
-        for (int i = 0; i < n_sessions; ++i) {
-                g_debug ("Considering session '%s'", sessions[i]);
-
-                if (!_systemd_session_is_graphical (sessions[i]))
-                        continue;
-
-                if (!_systemd_session_is_active (sessions[i]))
-                        continue;
-
-                /*
-                 * We get the sessions from newest to oldest, so take the last
-                 * one we find that's good
-                 */
-                local_session_id = sessions[i];
-        }
-
-        if (local_session_id == NULL) {
-                g_set_error (error,
-                             GDM_COMMON_ERROR,
-                             0,
-                             "Could not find a graphical session for user %d",
-                             uid);
-                return FALSE;
-        }
-
-        *out_session_id = g_strdup (local_session_id);
-
-        return TRUE;
 }
--- gdm-3.34.1-orig/common/gdm-common.h
+++ gdm-3.34.1/common/gdm-common.h
@@ -37,6 +37,11 @@
 
 #define GDM_SYSTEMD_SESSION_REQUIRE_ONLINE 0
 
+/* check if logind is running */
+#define LOGIND_RUNNING() (access("/run/systemd/seats/", F_OK) >= 0)
+
+#define GDM_SYSTEMD_SESSION_REQUIRE_ONLINE 0
+
 GQuark gdm_common_error_quark (void);
 #define GDM_COMMON_ERROR gdm_common_error_quark()
 
@@ -51,10 +56,6 @@
 int            gdm_signal_pid            (int pid,
                                           int signal);
 
-gboolean       gdm_find_display_session_for_uid (const uid_t uid,
-                                                 char      **out_session_id,
-                                                 GError    **error);
-
 gboolean       gdm_get_pwent_for_name    (const char     *name,
                                           struct passwd **pwentp);
 
@@ -81,10 +82,6 @@
 char *        gdm_shell_expand            (const char *str,
                                            GdmExpandVarFunc expand_func,
                                            gpointer user_data);
-
-gboolean      gdm_activate_session_by_id (GDBusConnection *connection,
-                                          const char      *seat_id,
-                                          const char      *session_id);
 
 G_END_DECLS
 
--- gdm-3.34.1-orig/common/gdm-log.c
+++ gdm-3.34.1/common/gdm-log.c
@@ -30,7 +30,9 @@
 #include <unistd.h>
 
 #include <syslog.h>
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #include <glib.h>
 #include <glib/gstdio.h>
@@ -125,12 +127,35 @@
 void
 gdm_log_init (void)
 {
+	const char *prg_name;
+	int         options;
+
         if (initialized)
                 return;
 
         initialized = TRUE;
 
+#ifdef WITH_SYSTEMD
+        is_sd_booted = sd_booted () > 0;
+#endif
+
         g_log_set_default_handler (gdm_log_default_handler, NULL);
+
+        /* Only set up syslog if !systemd, otherwise with systemd
+         * enabled, we keep the default GLib log handler which goes to
+         * stderr, which is routed to the appropriate place in the
+         * systemd service file.
+         */
+        if (!is_sd_booted) {
+                prg_name = g_get_prgname ();
+
+                options = LOG_PID;
+#ifdef LOG_PERROR
+                options |= LOG_PERROR;
+#endif
+
+                openlog (prg_name, options, LOG_DAEMON);
+        }
 }
 
 void
--- gdm-3.34.1-orig/configure.ac
+++ gdm-3.34.1/configure.ac
@@ -224,12 +224,6 @@
 AM_CONDITIONAL(ENABLE_LFS_PAM_CONFIG, test x$with_default_pam_config = xlfs)
 AM_CONDITIONAL(ENABLE_ARCH_PAM_CONFIG, test x$with_default_pam_config = xarch)
 
-AC_CHECK_HEADERS([security/pam_modules.h security/pam_modutil.h security/pam_ext.h],
-                 [have_pam=yes],
-                 [if test "x$have_pam" = xyes ; then
-                        AC_MSG_ERROR([PAM development files not found.])
-                 fi])
-
 AC_ARG_ENABLE(console-helper,
 	      AS_HELP_STRING([--enable-console-helper],
                              [Enable PAM console helper @<:@default=auto@:>@]),,
@@ -259,6 +253,17 @@
             AS_HELP_STRING([--with-udevdir=DIR],
                            [Directory for udev files]),
                 [with_udevdir=$withval], [with_udevdir=$($PKG_CONFIG --variable=udevdir udev)])
+
+AC_ARG_WITH(console-kit,
+            AS_HELP_STRING([--with-console-kit],
+                           [Add ConsoleKit support @<:@default=auto@:>@]),,
+            with_console_kit=no)
+
+AC_ARG_WITH(systemd,
+            AS_HELP_STRING([--with-systemd],
+                           [Add systemd support @<:@default=auto@:>@]),
+            [with_systemd=$withval], [with_systemd=auto])
+
 AC_ARG_WITH([systemdsystemunitdir],
             AS_HELP_STRING([--with-systemdsystemunitdir=DIR],
                            [Directory for systemd service files]),
@@ -464,74 +469,8 @@
 AC_SUBST(GDM_GROUPNAME)
 AC_DEFINE_UNQUOTED([GDM_GROUPNAME], "$GDM_GROUPNAME", [Group to use])
 
+have_pam=yes
 
-dnl ---------------------------------------------------------------------------
-dnl - Check for PAM stuff
-dnl ---------------------------------------------------------------------------
-
-dnl PAM prefix (configuration files)
-withval=""
-AC_ARG_WITH(pam-prefix,
-            AS_HELP_STRING([--with-pam-prefix=<prefix>],
-                           [specify where pam files go]),
-            [if test x$withval != x; then
-               AC_MSG_RESULT("PAM files will be installed in prefix ${withval}.")
-             fi])
-
-if test x$withval != x; then
-	PAM_PREFIX="$withval"
-else
-	PAM_PREFIX='${sysconfdir}'
-fi
-AC_SUBST(PAM_PREFIX)
-
-dnl PAM dir (dynamic modules)
-AC_ARG_WITH([pam-mod-dir],
-            [AS_HELP_STRING([--with-pam-mod-dir=DIR],
-                            [directory to install pam modules in])],
-            [], [with_pam_mod_dir='${libdir}/security'])
-PAM_MOD_DIR="$with_pam_mod_dir"
-AC_SUBST(PAM_MOD_DIR)
-
-have_pam=no
-AC_CHECK_LIB(pam, pam_start, have_pam=yes)
-
-if test "x$have_pam" = "xyes"; then
-        PAM_LIBS="${PAM_LIBS} -lpam"
-else
-	AC_MSG_ERROR("PAM libraries not found")
-fi
-AC_SUBST(HAVE_PAM)
-AC_SUBST(PAM_LIBS)
-
-AC_CHECK_HEADERS([security/pam_modutil.h security/pam_ext.h])
-AC_CHECK_LIB(pam, pam_syslog, [AC_DEFINE(HAVE_PAM_SYSLOG, [], [Define to 1 if you have the pam_syslog function])])
-
-dnl test whether struct pam_message is const (Linux) or not (Sun)
-if test "x$have_pam" = "xyes"; then
-   pam_appl_h="$ac_pam_includes/security/pam_appl.h"
-   AC_MSG_CHECKING(for const pam_message)
-   AC_EGREP_HEADER([struct pam_message],
-      $pam_appl_h,
-      [ AC_EGREP_HEADER([const struct pam_message],
-                        $pam_appl_h,
-                        [AC_MSG_RESULT(["const: Linux-type PAM"]) ],
-                        [AC_MSG_RESULT(["nonconst: Sun-type PAM"])
-                        AC_DEFINE(PAM_MESSAGE_NONCONST, 1, [Define if your PAM support takes non-const arguments (Solaris)])]
-                        )],
-       [AC_MSG_RESULT(["not found - assume const, Linux-type PAM"])]
-       )
-   AC_CHECK_DECL(PAM_BINARY_PROMPT,
-                 [supports_pam_extensions=yes],
-                 [supports_pam_extensions=no],
-                 #include <security/pam_appl.h>
-                )
-fi
-if test "x$supports_pam_extensions" = "xyes" ; then
-	AM_CONDITIONAL(SUPPORTS_PAM_EXTENSIONS, true)
-	AC_DEFINE(SUPPORTS_PAM_EXTENSIONS, 1, [Define if PAM supports GDMs custom extensions])
-fi
-
 AC_CHECK_LIB(keyutils, keyctl_read, [
         AC_DEFINE(HAVE_KEYUTILS, 1, [Define if have keyutils])
         KEYUTILS_LIBS="-lkeyutils"
@@ -613,14 +552,8 @@
 dnl - Check for utmp stuff
 dnl ---------------------------------------------------------------------------
 
-AC_CHECK_HEADERS(utmp.h utmpx.h libutil.h sys/param.h)
-AC_CHECK_FUNCS([getutxent updwtmpx updwtmp])
-AC_CHECK_LIB(util, login, [
-		   AC_DEFINE(HAVE_LOGIN, 1, [Define if have login])
-		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
-AC_CHECK_LIB(util, logout, [
-		   AC_DEFINE(HAVE_LOGOUT, 1, [Define if have logout])
-		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
+AC_CHECK_HEADERS(utmp.h utmpx.h util.h sys/param.h)
+AC_CHECK_FUNCS([getutxent getttyent updwtmpx updwtmp])
 AC_CHECK_LIB(util, logwtmp, [
 	  	   AC_DEFINE(HAVE_LOGWTMP, 1, [Define if have logwtmp])
 		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
@@ -829,12 +762,42 @@
 CPPFLAGS="$xinerama_save_cppflags"
 
 dnl ---------------------------------------------------------------------------
+dnl - Check for ConsoleKit support
+dnl ---------------------------------------------------------------------------
+
+use_console_kit=no
+if test "x$with_console_kit" != "xno" ; then
+	use_console_kit=yes
+	AC_DEFINE(WITH_CONSOLE_KIT, 1, [Define to enable ConsoleKit support])
+fi
+AM_CONDITIONAL(WITH_CONSOLE_KIT, test x$use_console_kit = xyes)
+AC_SUBST(WITH_CONSOLE_KIT)
+
+dnl ---------------------------------------------------------------------------
 dnl - Check for systemd support
 dnl ---------------------------------------------------------------------------
 
 PKG_CHECK_MODULES(SYSTEMD,
-                  [libsystemd])
+                  [libsystemd-login >= 186 libsystemd-daemon],
+                  [have_systemd=yes], [have_systemd=no])
 
+if test "x$with_systemd" = "xauto" ; then
+        if test x$have_systemd = xno ; then
+                use_systemd=no
+        else
+                use_systemd=yes
+        fi
+else
+        use_systemd="$with_systemd"
+fi
+
+if test "x$use_systemd" != "xno" ; then
+        if test "x$have_systemd" = "xno"; then
+                AC_MSG_ERROR([Systemd support explicitly required, but systemd not found])
+        fi
+
+        AC_DEFINE(WITH_SYSTEMD, 1, [Define to enable systemd support])
+fi
 AC_SUBST(SYSTEMD_CFLAGS)
 AC_SUBST(SYSTEMD_LIBS)
 
@@ -1027,6 +990,14 @@
 AC_SUBST(GDM_CUSTOM_CONF)
 AC_SUBST(GDM_OLD_CONF, '${gdmconfdir}/gdm.conf')
 
+AC_ARG_WITH(consolekit-directory,
+              [AC_HELP_STRING([--with-consolekit-directory],
+                              [Specify the directory of ck-get-x11-display-device @<:@default=libexecdir@:>@])],,
+                              [with_consolekit_directory="\${libexecdir}"])
+
+CONSOLEKIT_DIR=$with_consolekit_directory
+AC_SUBST(CONSOLEKIT_DIR)
+
 AC_ARG_WITH(gnome-settings-daemon-directory,
               [AC_HELP_STRING([--with-gnome-settings-daemon-directory],
                               [Specify the directory of gnome-settings-daemon used by the chooser @<:@default=libexecdir@:>@])],,
@@ -1490,6 +1461,7 @@
         dmconfdir:                ${dmconfdir}
         localstatedir:            ${localstatedir}
         datadir:                  ${datadir}
+	consolekit location:      ${with_consolekit_directory}
 	gnome-settings-daemon location: ${with_gnome_settings_daemon_directory}
 	gnome-session-check-accel location: ${with_check_accelerated_directory}
 	source code location:	  ${srcdir}
@@ -1520,6 +1492,8 @@
 "        Xinerama support:         ${XINERAMA_SUPPORT}
         XDMCP support:            ${XDMCP_SUPPORT}
         SELinux support:          ${use_selinux}
+        ConsoleKit support:       ${use_console_kit}
+        systemd support:          ${use_systemd}
         systemd unit dir:         ${with_systemdsystemunitdir}
         udev dir:                 ${with_udevdir}
         plymouth support:         ${use_plymouth}
@@ -1529,3 +1503,4 @@
         Enable documentation:     ${enable_documentation}
         Install GDM's Xsession:   ${enable_gdm_xsession}
 "
+
--- gdm-3.34.1-orig/daemon/Makefile.am
+++ gdm-3.34.1/daemon/Makefile.am
@@ -141,10 +141,6 @@
 	gdm-dbus-util.h				\
 	$(NULL)
 
-if SUPPORTS_PAM_EXTENSIONS
-gdm_session_worker_SOURCES += $(top_srcdir)/pam-extensions/gdm-pam-extensions.h
-endif
-
 nodist_gdm_session_worker_SOURCES =		\
 	gdm-session-glue.h			\
 	gdm-session-glue.c			\
--- gdm-3.34.1-orig/data/Init.in
+++ gdm-3.34.1/data/Init.in
@@ -6,6 +6,15 @@
 PATH="@X_PATH@:$PATH"
 OLD_IFS=$IFS
 
+# enhance fade in look
+xsetroot -solid black
+
+# wait for ttys to be initialized
+while ! pgrep -qf "^/usr/libexec/getty "; do
+	sleep 1
+	[ $((i++)) -ge 10 ] && break
+done
+
 gdmwhich () {
   COMMAND="$1"
   OUTPUT=
@@ -85,5 +94,15 @@
     fi
   fi
 fi
+
+# /etc/X11/xenodm/GiveConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown _gdm /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown _gdm /dev/drmR128
+fi
+# XXX OpenBSD needs an implementation of XDG_RUNTIME_DIR
+rm -rf /var/db/gdm/.cache/gnome-shell/runtime-state-*
 
 exit 0
--- gdm-3.34.1-orig/data/Makefile.am
+++ gdm-3.34.1/data/Makefile.am
@@ -220,6 +220,7 @@
 Xsession: $(srcdir)/Xsession.in
 	sed	-e 's,[@]XSESSION_SHELL[@],$(XSESSION_SHELL),g' \
 		-e 's,[@]libexecdir[@],$(libexecdir),g' \
+		-e 's,[@]X_PATH[@],$(X_PATH),g' \
 		<$(srcdir)/Xsession.in >Xsession
 Xsession_files += Xsession
 CLEANFILES += Xsession
@@ -293,7 +294,7 @@
 	if test '!' -d $(DESTDIR)$(logdir); then \
 		$(mkinstalldirs) $(DESTDIR)$(logdir); \
 		chmod 755 $(DESTDIR)$(logdir); \
-		chown root:root $(DESTDIR)$(logdir) || : ; \
+		chown root:wheel $(DESTDIR)$(logdir) || : ; \
 	fi
 
 	system=`uname`; \
@@ -316,29 +317,29 @@
 	if test '!' -d $(DESTDIR)$(xauthdir); then \
 		$(mkinstalldirs) $(DESTDIR)$(xauthdir); \
 		chmod 0711 $(DESTDIR)$(xauthdir); \
-		chown root:gdm $(DESTDIR)$(xauthdir) || : ; \
+		chown root:676 $(DESTDIR)$(xauthdir) || : ; \
 	fi
 
 	if test '!' -d $(DESTDIR)$(screenshotdir); then \
 		$(mkinstalldirs) $(DESTDIR)$(screenshotdir); \
 		chmod 0755 $(DESTDIR)$(screenshotdir); \
-		chown gdm:gdm $(DESTDIR)$(screenshotdir) || : ; \
+		chown 676:676 $(DESTDIR)$(screenshotdir) || : ; \
 	fi
 
 	if test '!' -d $(DESTDIR)$(workingdir); then \
 		$(mkinstalldirs) $(DESTDIR)$(workingdir); \
 		chmod 1770 $(DESTDIR)$(workingdir); \
-		chown root:gdm $(DESTDIR)$(workingdir) || : ; \
+		chown root:676 $(DESTDIR)$(workingdir) || : ; \
 	fi
 
 	if test '!' -d $(DESTDIR)$(workingdir)/.local/share/applications; then \
 		$(mkinstalldirs) $(DESTDIR)$(workingdir)/.local/share/applications; \
 		chmod 0755 $(DESTDIR)$(workingdir)/.local/share/applications; \
-		chown gdm:gdm $(DESTDIR)$(workingdir)/.local/share/applications || : ; \
+		chown 676:676 $(DESTDIR)$(workingdir)/.local/share/applications || : ; \
 	fi
 
 	if test '!' -d $(DESTDIR)$(cachedir); then \
 		$(mkinstalldirs) $(DESTDIR)$(cachedir); \
 		chmod 1755 $(DESTDIR)$(cachedir); \
-		chown root:gdm $(DESTDIR)$(cachedir) || : ; \
+		chown root:676 $(DESTDIR)$(cachedir) || : ; \
 	fi
--- gdm-3.34.1-orig/data/PostSession.in
+++ gdm-3.34.1/data/PostSession.in
@@ -1,3 +1,11 @@
 #!/bin/sh
 
+# /etc/X11/xenodm/TakeConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown root /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown root /dev/drmR128
+fi
+
 exit 0
--- gdm-3.34.1-orig/data/PreSession.in
+++ gdm-3.34.1/data/PreSession.in
@@ -7,3 +7,11 @@
 # Note that output goes into the .xsession-errors file for easy debugging
 #
 PATH="@X_PATH@:$PATH"
+
+# /etc/X11/xenodm/GiveConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown $USER /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown $USER /dev/drmR128
+fi
--- gdm-3.34.1-orig/libgdm/Makefile.am
+++ gdm-3.34.1/libgdm/Makefile.am
@@ -66,7 +66,6 @@
         $(END_OF_LIST)
 
 libgdm_la_LIBADD =                                                     \
-        $(top_builddir)/common/libgdmcommon.la                         \
         $(LIBGDM_LIBS)                                                 \
         $(SYSTEMD_LIBS)                                                \
         $(END_OF_LIST)
--- gdm-3.34.1-orig/libgdm/gdm-user-switching.c
+++ gdm-3.34.1/libgdm/gdm-user-switching.c
@@ -31,12 +31,25 @@
 #include <glib-object.h>
 #include <gio/gio.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "common/gdm-common.h"
 #include "gdm-user-switching.h"
 #include "gdm-client.h"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
 static gboolean
 create_transient_display (GDBusConnection *connection,
                           GCancellable    *cancellable,
@@ -67,16 +80,308 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
+
 static gboolean
-activate_session_id (GDBusConnection  *connection,
-                     GCancellable     *cancellable,
-                     const char       *seat_id,
-                     const char       *session_id,
-                     GError          **error)
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
 {
+        GError *local_error = NULL;
         GVariant *reply;
 
         reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
+gboolean
+activate_session_id_for_ck (GDBusConnection *connection,
+                            GCancellable    *cancellable,
+                            const char      *seat_id,
+                            const char      *session_id,
+                            GError         **error)
+{
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                g_prefix_error (error, _("Unable to activate session: "));
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+        gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
+static gboolean
+goto_login_session_for_ck (GDBusConnection  *connection,
+                           GCancellable     *cancellable,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, cancellable, seat_id, session_id, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, cancellable, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+
+gboolean
+activate_session_id_for_systemd (GDBusConnection  *connection,
+                                 GCancellable     *cancellable,
+                                 const char       *seat_id,
+                                 const char       *session_id,
+                                 GError          **error)
+{
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
                                              "org.freedesktop.login1.Manager",
@@ -97,8 +402,8 @@
 }
 
 static gboolean
-get_login_window_session_id (const char  *seat_id,
-                             char       **session_id)
+get_login_window_session_id_for_systemd (const char  *seat_id,
+                                         char       **session_id)
 {
         gboolean   ret;
         int        res, i;
@@ -182,16 +487,15 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
-                    GCancellable     *cancellable,
-                    GError          **error)
+goto_login_session_for_systemd (GDBusConnection  *connection,
+                                GCancellable     *cancellable,
+                                GError          **error)
 {
         gboolean        ret;
         int             res;
         char           *our_session;
         char           *session_id;
         char           *seat_id;
-        GError         *local_error = NULL;
 
         ret = FALSE;
         session_id = NULL;
@@ -203,9 +507,12 @@
         /* Note that we mostly use free () here, instead of g_free ()
          * since the data allocated is from libsystemd-logind, which
          * does not use GLib's g_malloc (). */
-        if (!gdm_find_display_session_for_uid (getuid (), &our_session, &local_error)) {
-                g_propagate_prefixed_error (error, local_error, _("Could not identify the current session: "));
 
+        res = sd_pid_get_session (0, &our_session);
+        if (res < 0) {
+                g_debug ("failed to determine own session: %s", strerror (-res));
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("Could not identify the current session."));
+
                 return FALSE;
         }
 
@@ -236,9 +543,9 @@
                 return FALSE;
         }
 
-        res = get_login_window_session_id (seat_id, &session_id);
+        res = get_login_window_session_id_for_systemd (seat_id, &session_id);
         if (res && session_id != NULL) {
-                res = activate_session_id (connection, cancellable, seat_id, session_id, error);
+                res = activate_session_id_for_systemd (connection, cancellable, seat_id, session_id, error);
 
                 if (res) {
                         ret = TRUE;
@@ -257,10 +564,11 @@
 
         return ret;
 }
+#endif
 
 gboolean
 gdm_goto_login_session_sync (GCancellable  *cancellable,
-                             GError       **error)
+			     GError       **error)
 {
         GDBusConnection *connection;
         gboolean retval;
@@ -269,8 +577,23 @@
         if (!connection)
                 return FALSE;
 
-        retval = goto_login_session (connection, cancellable, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                retval = goto_login_session_for_systemd (connection,
+                                                         cancellable,
+                                                         error);
 
+                g_object_unref (connection);
+                return retval;
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        retval = goto_login_session_for_ck (connection, cancellable, error);
+
         g_object_unref (connection);
         return retval;
+#else
+        return FALSE;
+#endif
 }
--- gdm-3.34.1-orig/pam-extensions/Makefile.am
+++ gdm-3.34.1/pam-extensions/Makefile.am
@@ -10,14 +10,6 @@
         -DDATADIR=\""$(datadir)"\"                                      \
         $(NULL)
 
-if SUPPORTS_PAM_EXTENSIONS
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = gdm-pam-extensions.pc
-
-pam_extensions_includedir = $(includedir)/gdm
-pam_extensions_include_HEADERS = gdm-pam-extensions.h
-endif
-
 EXTRA_DIST =                                                            \
         gdm-pam-extensions.pc.in                                        \
         $(NULL)
