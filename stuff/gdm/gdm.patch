diff -ruN gdm-3.34.1-orig/common/gdm-address.c gdm-3.34.1/common/gdm-address.c
--- gdm-3.34.1-orig/common/gdm-address.c	2017-07-11 19:44:52.000000000 +0900
+++ gdm-3.34.1/common/gdm-address.c	2019-10-10 03:48:54.482667801 +0900
@@ -29,6 +29,8 @@
 #include <stropts.h>
 #endif
 #include <string.h>
+#include <sys/types.h>
+#include <sys/param.h>
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -37,7 +39,6 @@
 #endif
 #include <netdb.h>
 #include <sys/ioctl.h>
-#include <net/if.h>
 
 #ifndef G_OS_WIN32
 #include <sys/select.h>
@@ -47,6 +48,7 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #endif
+#include <net/if.h>
 
 #include <glib-object.h>
 
diff -ruN gdm-3.34.1-orig/common/gdm-common.c gdm-3.34.1/common/gdm-common.c
--- gdm-3.34.1-orig/common/gdm-common.c	2019-09-25 03:10:25.000000000 +0900
+++ gdm-3.34.1/common/gdm-common.c	2019-10-10 03:48:54.482667801 +0900
@@ -36,12 +36,25 @@
 
 #include "gdm-common.h"
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #define GDM_DBUS_NAME                            "org.gnome.DisplayManager"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_PATH      "/org/gnome/DisplayManager/LocalDisplayFactory"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_INTERFACE "org.gnome.DisplayManager.LocalDisplayFactory"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
 G_DEFINE_QUARK (gdm-common-error, gdm_common_error);
 
 gboolean
@@ -352,8 +365,87 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
+gboolean
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
 gboolean
-gdm_activate_session_by_id (GDBusConnection *connection,
+activate_session_id_for_ck (GDBusConnection *connection,
                             const char      *seat_id,
                             const char      *session_id)
 {
@@ -361,6 +453,217 @@
         GVariant *reply;
 
         reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to activate session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+       gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
+static gboolean
+goto_login_session_for_ck (GDBusConnection  *connection,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_COMMON_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_COMMON_ERROR, 1, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, seat_id, session_id);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+
+gboolean
+activate_session_id_for_systemd (GDBusConnection *connection,
+                                 const char      *seat_id,
+                                 const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
                                              "org.freedesktop.login1.Manager",
@@ -382,8 +685,8 @@
 }
 
 gboolean
-gdm_get_login_window_session_id (const char  *seat_id,
-                                 char       **session_id)
+get_login_window_session_id_for_systemd (const char  *seat_id,
+                                         char       **session_id)
 {
         gboolean   ret;
         int        res, i;
@@ -476,8 +779,8 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
-                    GError          **error)
+goto_login_session_for_systemd (GDBusConnection  *connection,
+                                GError          **error)
 {
         gboolean        ret;
         int             res;
@@ -530,9 +833,9 @@
                 return FALSE;
         }
 
-        res = gdm_get_login_window_session_id (seat_id, &session_id);
+        res = get_login_window_session_id_for_systemd (seat_id, &session_id);
         if (res && session_id != NULL) {
-                res = gdm_activate_session_by_id (connection, seat_id, session_id);
+                res = activate_session_id_for_systemd (connection, seat_id, session_id);
 
                 if (res) {
                         ret = TRUE;
@@ -551,6 +854,7 @@
 
         return ret;
 }
+#endif
 
 gboolean
 gdm_goto_login_session (GError **error)
@@ -566,7 +870,17 @@
                 return FALSE;
         }
 
-        return goto_login_session (connection, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return goto_login_session_for_systemd (connection, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return goto_login_session_for_ck (connection, error);
+#else
+        return FALSE;
+#endif
 }
 
 static void
@@ -850,7 +1164,11 @@
         int saved_errno;
         g_autofree gchar *type = NULL;
 
+#ifdef HAVE_SYSTEMD
         saved_errno = sd_session_get_type (session_id, &type);
+#else
+        saved_errno = 1;
+#endif
         if (saved_errno < 0) {
                 g_warning ("Couldn't get type for session '%s': %s",
                            session_id,
@@ -881,7 +1199,11 @@
          * checking for a race condition since we specified
          * GDM_SYSTEMD_SESSION_REQUIRE_ONLINE)
          */
+#ifdef HAVE_SYSTEMD
         saved_errno = sd_session_get_state (session_id, &state);
+#else
+        saved_errno = 1;
+#endif
         if (saved_errno < 0) {
                 g_warning ("Couldn't get state for session '%s': %s",
                            session_id,
@@ -910,9 +1232,13 @@
 
         g_debug ("Finding a graphical session for user %d", uid);
 
+#ifdef HAVE_SYSTEMD
         n_sessions = sd_uid_get_sessions (uid,
                                           GDM_SYSTEMD_SESSION_REQUIRE_ONLINE,
                                           &sessions);
+#else
+        n_sessions = 1;
+#endif
 
         if (n_sessions < 0) {
                 g_set_error (error,
diff -ruN gdm-3.34.1-orig/common/gdm-common.h gdm-3.34.1/common/gdm-common.h
--- gdm-3.34.1-orig/common/gdm-common.h	2019-08-15 19:11:31.000000000 +0900
+++ gdm-3.34.1/common/gdm-common.h	2019-10-10 03:48:54.482667801 +0900
@@ -37,6 +37,9 @@
 
 #define GDM_SYSTEMD_SESSION_REQUIRE_ONLINE 0
 
+/* check if logind is running */
+#define LOGIND_RUNNING() (access("/run/systemd/seats/", F_OK) >= 0)
+
 GQuark gdm_common_error_quark (void);
 #define GDM_COMMON_ERROR gdm_common_error_quark()
 
@@ -82,10 +85,6 @@
                                            GdmExpandVarFunc expand_func,
                                            gpointer user_data);
 
-gboolean      gdm_activate_session_by_id (GDBusConnection *connection,
-                                          const char      *seat_id,
-                                          const char      *session_id);
-
 G_END_DECLS
 
 #endif /* _GDM_COMMON_H */
diff -ruN gdm-3.34.1-orig/common/gdm-log.c gdm-3.34.1/common/gdm-log.c
--- gdm-3.34.1-orig/common/gdm-log.c	2017-12-12 21:04:31.000000000 +0900
+++ gdm-3.34.1/common/gdm-log.c	2019-10-10 03:48:54.482667801 +0900
@@ -30,7 +30,9 @@
 #include <unistd.h>
 
 #include <syslog.h>
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #include <glib.h>
 #include <glib/gstdio.h>
@@ -125,12 +127,35 @@
 void
 gdm_log_init (void)
 {
+	const char *prg_name;
+	int         options;
+
         if (initialized)
                 return;
 
         initialized = TRUE;
 
+#ifdef WITH_SYSTEMD
+        is_sd_booted = sd_booted () > 0;
+#endif
+
         g_log_set_default_handler (gdm_log_default_handler, NULL);
+
+        /* Only set up syslog if !systemd, otherwise with systemd
+         * enabled, we keep the default GLib log handler which goes to
+         * stderr, which is routed to the appropriate place in the
+         * systemd service file.
+         */
+        if (!is_sd_booted) {
+                prg_name = g_get_prgname ();
+
+                options = LOG_PID;
+#ifdef LOG_PERROR
+                options |= LOG_PERROR;
+#endif
+
+                openlog (prg_name, options, LOG_DAEMON);
+        }
 }
 
 void
diff -ruN gdm-3.34.1-orig/configure.ac gdm-3.34.1/configure.ac
--- gdm-3.34.1-orig/configure.ac	2019-10-07 17:56:26.000000000 +0900
+++ gdm-3.34.1/configure.ac	2019-10-10 03:48:54.486001091 +0900
@@ -224,12 +224,6 @@
 AM_CONDITIONAL(ENABLE_LFS_PAM_CONFIG, test x$with_default_pam_config = xlfs)
 AM_CONDITIONAL(ENABLE_ARCH_PAM_CONFIG, test x$with_default_pam_config = xarch)
 
-AC_CHECK_HEADERS([security/pam_modules.h security/pam_modutil.h security/pam_ext.h],
-                 [have_pam=yes],
-                 [if test "x$have_pam" = xyes ; then
-                        AC_MSG_ERROR([PAM development files not found.])
-                 fi])
-
 AC_ARG_ENABLE(console-helper,
 	      AS_HELP_STRING([--enable-console-helper],
                              [Enable PAM console helper @<:@default=auto@:>@]),,
@@ -259,6 +253,17 @@
             AS_HELP_STRING([--with-udevdir=DIR],
                            [Directory for udev files]),
                 [with_udevdir=$withval], [with_udevdir=$($PKG_CONFIG --variable=udevdir udev)])
+
+AC_ARG_WITH(console-kit,
+            AS_HELP_STRING([--with-console-kit],
+                           [Add ConsoleKit support @<:@default=auto@:>@]),,
+            with_console_kit=no)
+
+AC_ARG_WITH(systemd,
+            AS_HELP_STRING([--with-systemd],
+                           [Add systemd support @<:@default=auto@:>@]),
+            [with_systemd=$withval], [with_systemd=auto])
+
 AC_ARG_WITH([systemdsystemunitdir],
             AS_HELP_STRING([--with-systemdsystemunitdir=DIR],
                            [Directory for systemd service files]),
@@ -493,44 +498,7 @@
 PAM_MOD_DIR="$with_pam_mod_dir"
 AC_SUBST(PAM_MOD_DIR)
 
-have_pam=no
-AC_CHECK_LIB(pam, pam_start, have_pam=yes)
-
-if test "x$have_pam" = "xyes"; then
-        PAM_LIBS="${PAM_LIBS} -lpam"
-else
-	AC_MSG_ERROR("PAM libraries not found")
-fi
-AC_SUBST(HAVE_PAM)
-AC_SUBST(PAM_LIBS)
-
-AC_CHECK_HEADERS([security/pam_modutil.h security/pam_ext.h])
-AC_CHECK_LIB(pam, pam_syslog, [AC_DEFINE(HAVE_PAM_SYSLOG, [], [Define to 1 if you have the pam_syslog function])])
-
-dnl test whether struct pam_message is const (Linux) or not (Sun)
-if test "x$have_pam" = "xyes"; then
-   pam_appl_h="$ac_pam_includes/security/pam_appl.h"
-   AC_MSG_CHECKING(for const pam_message)
-   AC_EGREP_HEADER([struct pam_message],
-      $pam_appl_h,
-      [ AC_EGREP_HEADER([const struct pam_message],
-                        $pam_appl_h,
-                        [AC_MSG_RESULT(["const: Linux-type PAM"]) ],
-                        [AC_MSG_RESULT(["nonconst: Sun-type PAM"])
-                        AC_DEFINE(PAM_MESSAGE_NONCONST, 1, [Define if your PAM support takes non-const arguments (Solaris)])]
-                        )],
-       [AC_MSG_RESULT(["not found - assume const, Linux-type PAM"])]
-       )
-   AC_CHECK_DECL(PAM_BINARY_PROMPT,
-                 [supports_pam_extensions=yes],
-                 [supports_pam_extensions=no],
-                 #include <security/pam_appl.h>
-                )
-fi
-if test "x$supports_pam_extensions" = "xyes" ; then
-	AM_CONDITIONAL(SUPPORTS_PAM_EXTENSIONS, true)
-	AC_DEFINE(SUPPORTS_PAM_EXTENSIONS, 1, [Define if PAM supports GDMs custom extensions])
-fi
+have_pam=yes
 
 AC_CHECK_LIB(keyutils, keyctl_read, [
         AC_DEFINE(HAVE_KEYUTILS, 1, [Define if have keyutils])
@@ -613,14 +581,8 @@
 dnl - Check for utmp stuff
 dnl ---------------------------------------------------------------------------
 
-AC_CHECK_HEADERS(utmp.h utmpx.h libutil.h sys/param.h)
-AC_CHECK_FUNCS([getutxent updwtmpx updwtmp])
-AC_CHECK_LIB(util, login, [
-		   AC_DEFINE(HAVE_LOGIN, 1, [Define if have login])
-		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
-AC_CHECK_LIB(util, logout, [
-		   AC_DEFINE(HAVE_LOGOUT, 1, [Define if have logout])
-		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
+AC_CHECK_HEADERS(utmp.h utmpx.h util.h sys/param.h)
+AC_CHECK_FUNCS([getutxent getttyent updwtmpx updwtmp])
 AC_CHECK_LIB(util, logwtmp, [
 	  	   AC_DEFINE(HAVE_LOGWTMP, 1, [Define if have logwtmp])
 		       EXTRA_DAEMON_LIBS="$EXTRA_DAEMON_LIBS -lutil" ])
@@ -829,12 +791,42 @@
 CPPFLAGS="$xinerama_save_cppflags"
 
 dnl ---------------------------------------------------------------------------
+dnl - Check for ConsoleKit support
+dnl ---------------------------------------------------------------------------
+
+use_console_kit=no
+if test "x$with_console_kit" != "xno" ; then
+	use_console_kit=yes
+	AC_DEFINE(WITH_CONSOLE_KIT, 1, [Define to enable ConsoleKit support])
+fi
+AM_CONDITIONAL(WITH_CONSOLE_KIT, test x$use_console_kit = xyes)
+AC_SUBST(WITH_CONSOLE_KIT)
+
+dnl ---------------------------------------------------------------------------
 dnl - Check for systemd support
 dnl ---------------------------------------------------------------------------
 
 PKG_CHECK_MODULES(SYSTEMD,
-                  [libsystemd])
+                  [libsystemd-login >= 186 libsystemd-daemon],
+                  [have_systemd=yes], [have_systemd=no])
+
+if test "x$with_systemd" = "xauto" ; then
+        if test x$have_systemd = xno ; then
+                use_systemd=no
+        else
+                use_systemd=yes
+        fi
+else
+        use_systemd="$with_systemd"
+fi
 
+if test "x$use_systemd" != "xno" ; then
+        if test "x$have_systemd" = "xno"; then
+                AC_MSG_ERROR([Systemd support explicitly required, but systemd not found])
+        fi
+
+        AC_DEFINE(WITH_SYSTEMD, 1, [Define to enable systemd support])
+fi
 AC_SUBST(SYSTEMD_CFLAGS)
 AC_SUBST(SYSTEMD_LIBS)
 
@@ -1027,6 +1019,14 @@
 AC_SUBST(GDM_CUSTOM_CONF)
 AC_SUBST(GDM_OLD_CONF, '${gdmconfdir}/gdm.conf')
 
+AC_ARG_WITH(consolekit-directory,
+              [AC_HELP_STRING([--with-consolekit-directory],
+                              [Specify the directory of ck-get-x11-display-device @<:@default=libexecdir@:>@])],,
+                              [with_consolekit_directory="\${libexecdir}"])
+
+CONSOLEKIT_DIR=$with_consolekit_directory
+AC_SUBST(CONSOLEKIT_DIR)
+
 AC_ARG_WITH(gnome-settings-daemon-directory,
               [AC_HELP_STRING([--with-gnome-settings-daemon-directory],
                               [Specify the directory of gnome-settings-daemon used by the chooser @<:@default=libexecdir@:>@])],,
@@ -1080,7 +1080,7 @@
 if test ${check_sun_audit} = yes
 then
    AC_DEFINE(HAVE_ADT, 1, [Define if have adt])
-   PAM_LIBS="$PAM_LIBS -lbsm"
+   PAM_LIBS="$PAM_LIBS-lbsm"
    AC_MSG_RESULT(yes)
 else
    AC_MSG_RESULT(no)
@@ -1490,6 +1490,7 @@
         dmconfdir:                ${dmconfdir}
         localstatedir:            ${localstatedir}
         datadir:                  ${datadir}
+	consolekit location:      ${with_consolekit_directory}
 	gnome-settings-daemon location: ${with_gnome_settings_daemon_directory}
 	gnome-session-check-accel location: ${with_check_accelerated_directory}
 	source code location:	  ${srcdir}
@@ -1520,6 +1521,8 @@
 "        Xinerama support:         ${XINERAMA_SUPPORT}
         XDMCP support:            ${XDMCP_SUPPORT}
         SELinux support:          ${use_selinux}
+        ConsoleKit support:       ${use_console_kit}
+        systemd support:          ${use_systemd}
         systemd unit dir:         ${with_systemdsystemunitdir}
         udev dir:                 ${with_udevdir}
         plymouth support:         ${use_plymouth}
@@ -1529,3 +1532,4 @@
         Enable documentation:     ${enable_documentation}
         Install GDM's Xsession:   ${enable_gdm_xsession}
 "
+
diff -ruN gdm-3.34.1-orig/daemon/Makefile.am gdm-3.34.1/daemon/Makefile.am
--- gdm-3.34.1-orig/daemon/Makefile.am	2019-08-15 19:11:31.000000000 +0900
+++ gdm-3.34.1/daemon/Makefile.am	2019-10-10 03:48:54.486001091 +0900
@@ -21,6 +21,7 @@
 	-DGDM_SCREENSHOT_DIR=\"$(GDM_SCREENSHOT_DIR)\"		\
 	-DGDM_CACHE_DIR=\""$(localstatedir)/cache/gdm"\"	\
 	-DGDM_SESSION_DEFAULT_PATH=\"$(GDM_SESSION_DEFAULT_PATH)\" \
+	-DCONSOLEKIT_DIR=\"$(CONSOLEKIT_DIR)\" \
 	$(DISABLE_DEPRECATED_CFLAGS)			\
 	$(DAEMON_CFLAGS)				\
 	$(XLIB_CFLAGS)					\
@@ -141,10 +142,6 @@
 	gdm-dbus-util.h				\
 	$(NULL)
 
-if SUPPORTS_PAM_EXTENSIONS
-gdm_session_worker_SOURCES += $(top_srcdir)/pam-extensions/gdm-pam-extensions.h
-endif
-
 nodist_gdm_session_worker_SOURCES =		\
 	gdm-session-glue.h			\
 	gdm-session-glue.c			\
@@ -278,6 +275,11 @@
 	$(XDMCP_SOURCES)	\
 	$(NULL)
 
+CONSOLE_KIT_SOURCES = 		\
+	$(NULL)
+
+EXTRA_gdm_SOURCES += $(CONSOLE_KIT_SOURCES)
+
 gdm_LDADD = \
 	$(top_builddir)/common/libgdmcommon.la	\
 	$(XLIB_LIBS)				\
@@ -289,6 +291,10 @@
 	$(EXTRA_DAEMON_LIBS)			\
 	$(NULL)
 
+if WITH_CONSOLE_KIT
+gdm_SOURCES += $(CONSOLE_KIT_SOURCES)
+endif
+
 CLEANFILES =					\
 	gdm-display-glue.c			\
 	gdm-local-display-factory-glue.c	\
diff -ruN gdm-3.34.1-orig/data/Init.in gdm-3.34.1/data/Init.in
--- gdm-3.34.1-orig/data/Init.in	2017-07-11 19:44:52.000000000 +0900
+++ gdm-3.34.1/data/Init.in	2019-10-10 03:48:54.486001091 +0900
@@ -6,6 +6,15 @@
 PATH="@X_PATH@:$PATH"
 OLD_IFS=$IFS
 
+# enhance fade in look
+xsetroot -solid black
+
+# wait for ttys to be initialized
+while ! pgrep -qf "^/usr/libexec/getty "; do
+	sleep 1
+	[ $((i++)) -ge 10 ] && break
+done
+
 gdmwhich () {
   COMMAND="$1"
   OUTPUT=
@@ -86,4 +95,14 @@
   fi
 fi
 
+# /etc/X11/xenodm/GiveConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown _gdm /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown _gdm /dev/drmR128
+fi
+# XXX OpenBSD needs an implementation of XDG_RUNTIME_DIR
+rm -rf /var/db/gdm/.cache/gnome-shell/runtime-state-*
+
 exit 0
diff -ruN gdm-3.34.1-orig/data/Makefile.am gdm-3.34.1/data/Makefile.am
--- gdm-3.34.1-orig/data/Makefile.am	2019-08-15 19:11:31.000000000 +0900
+++ gdm-3.34.1/data/Makefile.am	2019-10-10 03:48:54.486001091 +0900
@@ -220,6 +220,7 @@
 Xsession: $(srcdir)/Xsession.in
 	sed	-e 's,[@]XSESSION_SHELL[@],$(XSESSION_SHELL),g' \
 		-e 's,[@]libexecdir[@],$(libexecdir),g' \
+		-e 's,[@]X_PATH[@],$(X_PATH),g' \
 		<$(srcdir)/Xsession.in >Xsession
 Xsession_files += Xsession
 CLEANFILES += Xsession
diff -ruN gdm-3.34.1-orig/data/PostSession.in gdm-3.34.1/data/PostSession.in
--- gdm-3.34.1-orig/data/PostSession.in	2017-07-11 19:44:52.000000000 +0900
+++ gdm-3.34.1/data/PostSession.in	2019-10-10 03:48:54.486001091 +0900
@@ -1,3 +1,11 @@
 #!/bin/sh
 
+# /etc/X11/xenodm/TakeConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown root /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown root /dev/drmR128
+fi
+
 exit 0
diff -ruN gdm-3.34.1-orig/data/PreSession.in gdm-3.34.1/data/PreSession.in
--- gdm-3.34.1-orig/data/PreSession.in	2017-07-11 19:44:52.000000000 +0900
+++ gdm-3.34.1/data/PreSession.in	2019-10-10 03:48:54.486001091 +0900
@@ -7,3 +7,11 @@
 # Note that output goes into the .xsession-errors file for easy debugging
 #
 PATH="@X_PATH@:$PATH"
+
+# /etc/X11/xenodm/GiveConsole, fbtab(5)
+if [ -c /dev/drm0 ]; then
+    /sbin/chown $USER /dev/drm0
+fi
+if [ -c /dev/drmR128 ]; then
+    /sbin/chown $USER /dev/drmR128
+fi
diff -ruN gdm-3.34.1-orig/libgdm/gdm-user-switching.c gdm-3.34.1/libgdm/gdm-user-switching.c
--- gdm-3.34.1-orig/libgdm/gdm-user-switching.c	2019-08-15 19:11:31.000000000 +0900
+++ gdm-3.34.1/libgdm/gdm-user-switching.c	2019-10-10 03:49:34.499178123 +0900
@@ -31,12 +31,25 @@
 #include <glib-object.h>
 #include <gio/gio.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "common/gdm-common.h"
 #include "gdm-user-switching.h"
 #include "gdm-client.h"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
 static gboolean
 create_transient_display (GDBusConnection *connection,
                           GCancellable    *cancellable,
@@ -67,12 +80,305 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
+
+static gboolean
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
 static gboolean
-activate_session_id (GDBusConnection  *connection,
-                     GCancellable     *cancellable,
-                     const char       *seat_id,
-                     const char       *session_id,
-                     GError          **error)
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+/*
+gboolean
+activate_session_id_for_ck (GDBusConnection *connection,
+                            GCancellable    *cancellable,
+                            const char      *seat_id,
+                            const char      *session_id,
+                            GError         **error)
+{
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                g_prefix_error (error, _("Unable to activate session: "));
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+*/
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+        gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
+static gboolean
+goto_login_session_for_ck (GDBusConnection  *connection,
+                           GCancellable     *cancellable,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, cancellable, seat_id, session_id, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, cancellable, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+
+gboolean
+activate_session_id_for_systemd (GDBusConnection  *connection,
+                                 GCancellable     *cancellable,
+                                 const char       *seat_id,
+                                 const char       *session_id,
+                                 GError          **error)
 {
         GVariant *reply;
 
@@ -97,8 +403,8 @@
 }
 
 static gboolean
-get_login_window_session_id (const char  *seat_id,
-                             char       **session_id)
+get_login_window_session_id_for_systemd (const char  *seat_id,
+                                         char       **session_id)
 {
         gboolean   ret;
         int        res, i;
@@ -182,9 +488,9 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
-                    GCancellable     *cancellable,
-                    GError          **error)
+goto_login_session_for_systemd (GDBusConnection  *connection,
+                                GCancellable     *cancellable,
+                                GError          **error)
 {
         gboolean        ret;
         int             res;
@@ -236,9 +542,9 @@
                 return FALSE;
         }
 
-        res = get_login_window_session_id (seat_id, &session_id);
+        res = get_login_window_session_id_for_systemd (seat_id, &session_id);
         if (res && session_id != NULL) {
-                res = activate_session_id (connection, cancellable, seat_id, session_id, error);
+                res = activate_session_id_for_systemd (connection, cancellable, seat_id, session_id, error);
 
                 if (res) {
                         ret = TRUE;
@@ -257,10 +563,11 @@
 
         return ret;
 }
+#endif
 
 gboolean
 gdm_goto_login_session_sync (GCancellable  *cancellable,
-                             GError       **error)
+			     GError       **error)
 {
         GDBusConnection *connection;
         gboolean retval;
@@ -269,8 +576,23 @@
         if (!connection)
                 return FALSE;
 
-        retval = goto_login_session (connection, cancellable, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                retval = goto_login_session_for_systemd (connection,
+                                                         cancellable,
+                                                         error);
+
+                g_object_unref (connection);
+                return retval;
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        retval = goto_login_session_for_ck (connection, cancellable, error);
 
         g_object_unref (connection);
         return retval;
+#else
+        return FALSE;
+#endif
 }
diff -ruN gdm-3.34.1-orig/Makefile.am gdm-3.34.1/Makefile.am
--- gdm-3.34.1-orig/Makefile.am	2018-10-24 20:56:07.000000000 +0900
+++ gdm-3.34.1/Makefile.am	2019-10-10 03:48:54.482667801 +0900
@@ -7,7 +7,6 @@
 	daemon 			\
 	libgdm 			\
 	utils 			\
-	pam_gdm			\
 	po 			\
 	tests 			\
 	$(NULL)
diff -ruN gdm-3.34.1-orig/pam-extensions/Makefile.am gdm-3.34.1/pam-extensions/Makefile.am
--- gdm-3.34.1-orig/pam-extensions/Makefile.am	2019-08-15 19:11:19.000000000 +0900
+++ gdm-3.34.1/pam-extensions/Makefile.am	2019-10-10 03:48:54.486001091 +0900
@@ -10,14 +10,6 @@
         -DDATADIR=\""$(datadir)"\"                                      \
         $(NULL)
 
-if SUPPORTS_PAM_EXTENSIONS
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = gdm-pam-extensions.pc
-
-pam_extensions_includedir = $(includedir)/gdm
-pam_extensions_include_HEADERS = gdm-pam-extensions.h
-endif
-
 EXTRA_DIST =                                                            \
         gdm-pam-extensions.pc.in                                        \
         $(NULL)
